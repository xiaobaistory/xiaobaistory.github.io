<<<<<<< HEAD
---
layout: null
---
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>{{ site.title | xml_escape }}</title>
    <description>{{ site.description | xml_escape }}</description>
    <link>{{ site.url }}{{ site.baseurl }}/</link>
    <atom:link href="{{ "/feed.xml" | prepend: site.baseurl | prepend: site.url }}" rel="self" type="application/rss+xml"/>
    <pubDate>{{ site.time | date_to_rfc822 }}</pubDate>
    <lastBuildDate>{{ site.time | date_to_rfc822 }}</lastBuildDate>
    <generator>Jekyll v{{ jekyll.version }}</generator>
    {% for post in site.posts limit:10 %}
      <item>
        <title>{{ post.title | xml_escape }}</title>
        <description>{{ post.content | xml_escape }}</description>
        <pubDate>{{ post.date | date_to_rfc822 }}</pubDate>
        <link>{{ post.url | prepend: site.baseurl | prepend: site.url }}</link>
        <guid isPermaLink="true">{{ post.url | prepend: site.baseurl | prepend: site.url }}</guid>
        {% for tag in post.tags %}
        <category>{{ tag | xml_escape }}</category>
        {% endfor %}
        {% for cat in post.categories %}
        <category>{{ cat | xml_escape }}</category>
        {% endfor %}
      </item>
    {% endfor %}
=======
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>曾静的技术博客</title>
    <description>嗨，我是曾静 (@devzeng)，iOS开发新人，目前暂居深圳。</description>
    <link>http://blog.devzeng.com/</link>
    <atom:link href="http://blog.devzeng.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 24 Mar 2016 18:03:41 +0800</pubDate>
    <lastBuildDate>Thu, 24 Mar 2016 18:03:41 +0800</lastBuildDate>
    <generator>Jekyll v3.1.1</generator>
    
      <item>
        <title>React Native开发初探</title>
        <description>&lt;p&gt;&lt;img src=&quot;/images/hello-react-native/react-native-logo.jpg&quot; alt=&quot;React Native Logo&quot;&gt;&lt;/p&gt;

&lt;p&gt;Facebook在React.js Conf 2015大会(2015.3.26)上开源了React Native。最开始只支持iOS，2015年9月15日发布了React Native for Android，至此React Native支持主流的两大平台（iOS和Android）。&lt;/p&gt;

&lt;p&gt;新事物的出现，都会引发行业的热烈讨论，自React Native发布起，一直都是热门的讨论话题。React Native的出现在一定程度上解决了我们目前在移动开发上面临的问题。我们身处在移动互联网的黄金时代，越来越多的业务移植到移动端。我们都清楚，原生的APP开发是需要一定的门槛的，这就导致了市场需求大，而相关的开发人员稀缺的问题。相比较而言，React Native采用的开发语言是JavaScript，相关的开发者也就比较多。&lt;/p&gt;

&lt;p&gt;如果你是一个原生APP的开发者，React Native的出现会帮你打开一扇门，会让你发掘开发中的更多可能性(比如跨平台开发、动态更新等等)。如果你是使用JavaScript的开发者，它的出现无疑会带来巨大的影响，会有越来越多的前端开发人员投入到移动APP开发的领域。&lt;/p&gt;

&lt;p&gt;本文主要是介绍React Native在本人开发中的一些实践，React Native的详细使用是一个很庞大的话题，本文不会详细介绍，建议仔细阅读官方的文档和示例程序。&lt;/p&gt;

&lt;h3&gt;React Native背景&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;What we really want is the &lt;strong&gt;user experience&lt;/strong&gt; of the &lt;strong&gt;native mobile&lt;/strong&gt; platforms, combined with the &lt;strong&gt;developer experience&lt;/strong&gt; we have when building with &lt;strong&gt;React&lt;/strong&gt; on the web.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的这段话摘自&lt;a href=&quot;http://facebook.github.io/react/blog/2015/03/26/introducing-react-native.html&quot;&gt;《Introducing React Native》&lt;/a&gt;，加粗的关键字传达了React Native的设计理念：既拥有Native的用户体验，又保留React的开发效率。这个理念迎合了业界普遍存在的痛点，开源不到一周github star过万，目前是26162(2016/01/22)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hello-react-native/react-native-github-stars.png&quot; alt=&quot;react-native-github-stars.png&quot;&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;#39;s worth noting that we&amp;#39;re not chasing “&lt;strong&gt;write once, run anywhere.&lt;/strong&gt;” Different platforms have different looks, feels, and capabilities, and as such, we should still be developing discrete apps for each platform, but the same set of engineers should be able to build applications for whatever platform they choose, without needing to learn a fundamentally different set of technologies for each. We call this approach “&lt;strong&gt;learn once, write anywhere&lt;/strong&gt;.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的这段话也是摘自&lt;a href=&quot;http://facebook.github.io/react/blog/2015/03/26/introducing-react-native.html&quot;&gt;《Introducing React Native》&lt;/a&gt;，在软件开发中最理想的情况是像Java这样“write once, run anywhere”，但是不同的平台有不同的用户体验(looks, feels, and capabilities)，过分要求应用在不同的平台上的一致性是不太合适的。React Native提出了一种理念，learn once, write anywhere， 可以在不同平台上编写基于React的代码。&lt;/p&gt;

&lt;h3&gt;开发环境配置&lt;/h3&gt;

&lt;p&gt;1.需要一台Mac(OSX)，上面要安装Xcode(建议Xcode7及以上的版本)，Xcode可以在Mac App Store下载&lt;/p&gt;

&lt;p&gt;2.安装Homebrew，后面安装Watchman和Flow推荐使用Homebrew安装&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果之前安装过Homebrew，可以先更新下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brew update &amp;amp;&amp;amp; brew upgrade&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3.安装node.js&lt;/p&gt;

&lt;p&gt;(1)安装nvm(Node Version Manager)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(2)安装最新版本的Node.js&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nvm install node &amp;amp;&amp;amp; nvm alias default node&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当然可以直接到Node.js官网下载dmg文件直接安装，下载地址是&lt;code&gt;https://nodejs.org/download/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4.建议安装watchman：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brew install watchman&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;5.安装flow：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brew install flow&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ok，按照以上步骤，你应该已经配置好了环境。&lt;/p&gt;

&lt;h3&gt;在现有项目中集成&lt;/h3&gt;

&lt;h4&gt;1.CocoaPods&lt;/h4&gt;

&lt;p&gt;推荐使用CocoaPods的方式进行集成，如果没有使用过，可以参考&lt;a href=&quot;http://blog.devzeng.com/blog/ios-cocoapods-dependency-manager.html&quot;&gt;《使用CocoaPods管理iOS项目中的依赖库》&lt;/a&gt;这篇文章安装配置。&lt;/p&gt;

&lt;h4&gt;2.安装react-native package&lt;/h4&gt;

&lt;p&gt;react native现在使用npm的方式进行安装&lt;/p&gt;

&lt;p&gt;(1)如果没有安装Node.js,需要按照前面的方式进行安装&lt;/p&gt;

&lt;p&gt;(2)安装完Node.js之后再项目根目录(.xcodeproj文件所在目录)下执行&lt;code&gt;npm install react-native&lt;/code&gt;的命令，执行完成之后会创建一个node_modules的文件夹。&lt;/p&gt;

&lt;h4&gt;3.修改Podfile配置&lt;/h4&gt;

&lt;p&gt;在项目根目录下的Podfile（如果没有该文件可以使用pod init命令生成）文件中加入如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pod &amp;#39;React&amp;#39;, :path =&amp;gt; &amp;#39;./node_modules/react-native&amp;#39;, :subspecs =&amp;gt; [
  &amp;#39;Core&amp;#39;,
  &amp;#39;RCTImage&amp;#39;,
  &amp;#39;RCTNetwork&amp;#39;,
  &amp;#39;RCTText&amp;#39;,
  &amp;#39;RCTWebSocket&amp;#39;,
  #添加其他需要的subspecs
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果你在项目中使用了&lt;code&gt;&amp;lt;Text&amp;gt;&lt;/code&gt;的组件，那么你必须添加&lt;code&gt;RCTText&lt;/code&gt;的subspecs。配置完成之后执行&lt;code&gt;pod install&lt;/code&gt;即可。&lt;/p&gt;

&lt;h4&gt;4.编写React Native代码&lt;/h4&gt;

&lt;p&gt;(1)在项目的根目录创建存放React Native代码的目录：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;mkdir ReactComponent
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;(2)新建一个示例的index.ios.js的代码&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;touch ReactComponent/index.ios.js
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;index.ios.js文件内容，示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;#39;use strict&amp;#39;;

var React = require(&amp;#39;react-native&amp;#39;);
var {
  Text,
  View
} = React;

var styles = React.StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &amp;#39;red&amp;#39;
  }
});

class SimpleApp extends React.Component {
  render() {
    return (
      &amp;lt;View style={styles.container}&amp;gt;
        &amp;lt;Text&amp;gt;This is a simple application.&amp;lt;/Text&amp;gt;
      &amp;lt;/View&amp;gt;
    )
  }
}

React.AppRegistry.registerComponent(&amp;#39;SimpleApp&amp;#39;, () =&amp;gt; SimpleApp);
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;SimpleApp&lt;/code&gt;即为你的Module Name,在后面会使用到。&lt;/p&gt;

&lt;h4&gt;5.在项目中加载React Native代码&lt;/h4&gt;

&lt;p&gt;React Native不是通过UIWebView的方式进行代码的加载，而是使用了&lt;code&gt;RCTRootView&lt;/code&gt;自定义的组件。RCTRootView提供了一个初始化的方法，支持在初始化视图组件的时候加载React的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (instancetype)initWithBundleURL:(NSURL *)bundleURL
                       moduleName:(NSString *)moduleName
                initialProperties:(NSDictionary *)initialProperties
                    launchOptions:(NSDictionary *)launchOptions;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;使用方式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NSURL *jsCodeLocation = [NSURL URLWithString:@&amp;quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;quot;];
RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation
                                                    moduleName: @&amp;quot;SimpleApp&amp;quot;
                                             initialProperties:nil
                                                 launchOptions:nil];
[self.view addSubview:rootView];
rootView.frame = self.view.bounds;                                              
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;需要指出的是在初始化的时候支持通过URL的方式进行加载，上面的方法是在线的服务器地址使用在发布环境下替换localhost为正式服务器的地址，另外一个是Bundle的路径地址,示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NSURL *jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&amp;quot;main&amp;quot; withExtension:@&amp;quot;jsbundle&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;为了生成jsbundle文件，可以通过下面的命令：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl http://localhost:8081/index.ios.bundle -o main.jsbundle&lt;/code&gt;&lt;/p&gt;

&lt;h4&gt;6.启动Development Server&lt;/h4&gt;

&lt;p&gt;终端进入项目所在根目录，执行下面的代码&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;(JS_DIR=`pwd`/ReactComponent; cd node_modules/react-native; npm run start -- --root $JS_DIR)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;启动完成之后可以通过：&lt;code&gt;http://localhost:8081/index.ios.bundle&lt;/code&gt;进行调用&lt;/p&gt;

&lt;h3&gt;Native和React的交互&lt;/h3&gt;

&lt;p&gt;关于React Native的通信机制，这里不再介绍，推荐两篇文章：&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&quot;http://blog.cnbang.net/tech/2698/&quot;&gt;《React Native通信机制详解》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;http://www.hotobear.com/?p=1015&quot;&gt;《React Native 初探（iOS）》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通信的流程图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hello-react-native/react-native-communication.png&quot; alt=&quot;react-native-communication.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;React Native中JavaScript和Native之间交互是同Module的方式进行的。Module是一个实现RCTBridgeModule协议的普通Objective-C的类，示例如下：&lt;/p&gt;

&lt;p&gt;在.h文件中实现&lt;code&gt;RCTBridgeModule&lt;/code&gt;的协议，示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;//CalendarManager.h
#import &amp;quot;RCTBridgeModule.h&amp;quot;

@interface CalendarManager : NSObject &amp;lt;RCTBridgeModule&amp;gt;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在.m文件中声明是Module，添加&lt;code&gt;RCT_EXPORT_MODULE&lt;/code&gt;的标记，示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// CalendarManager.m
@implementation CalendarManager

RCT_EXPORT_MODULE();

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;1.JavaScript调用Native Method&lt;/h4&gt;

&lt;p&gt;(1)Native的Module中使用RCT_EXPORT_METHOD()标记方法:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;RCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location) {
  RCTLogInfo(@&amp;quot;Pretending to create an event %@ at %@&amp;quot;, name, location);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;(2)在JavaScript代码中使用&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var CalendarManager = require(&amp;#39;react-native&amp;#39;).NativeModules.CalendarManager;
CalendarManager.addEvent(&amp;#39;Birthday Party&amp;#39;, &amp;#39;4 Privet Drive, Surrey&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;2.Native发送Events -&amp;gt; JavaScript&lt;/h4&gt;

&lt;p&gt;在西北督查中心项目表单的填写页面上右上角放了一个提交按钮，点击提交按钮后iOS的Objective-C会向React的Javascript代码发送消息，代码示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NSDictionary *parameters = @{@&amp;quot;data&amp;quot;:@&amp;quot;hello&amp;quot;};
[self.rootView.bridge.eventDispatcher sendDeviceEventWithName:@&amp;quot;DemoEventName&amp;quot; body:parameters];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;JavaScript端的处理代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;var subscription;
//在组件mount的时候注册
subscription = DeviceEventEmitter.addListener(&amp;#39;DemoEventName&amp;#39;, (data) =&amp;gt; {
      //todo something
});
//在组件unmount的时候移除
subscription.remove();
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;更多用法请参考官方文档中关于Native Modules的介绍&lt;a href=&quot;http://facebook.github.io/react-native/docs/native-modules-ios.html#content&quot;&gt;《Native Modules》&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;1.&lt;a href=&quot;http://facebook.github.io/react-native/&quot;&gt;《React Native官方文档》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;https://github.com/tmallfe/tmallfe.github.io/issues/18&quot;&gt;《React Native概述：背景、规划和风险》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;http://www.race604.com/react-native-component-lifecycle/&quot;&gt;《React Native 中组件的生命周期》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;https://github.com/vczero/react-native-lesson&quot;&gt;《React-Native入门指南》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Jan 2016 18:49:35 +0800</pubDate>
        <link>http://blog.devzeng.com/hello-react-native.html</link>
        <guid isPermaLink="true">http://blog.devzeng.com/hello-react-native.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>在iOS9中使用3D Touch</title>
        <description>&lt;p&gt;在iPhone 6s和iPhone 6s Plus中Apple引入了3D Touch技术。3D Touch的触控技术，被苹果称为新一代多点触控技术。其实，就是此前在Apple Watch上采用的Force Touch，屏幕可感应不同的感压力度。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios9_3d_touch/ios_3d_touch.png&quot; alt=&quot;ios_3d_touch.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;iOS9提供了四类API（&lt;code&gt;Home Screen Quick Action&lt;/code&gt;、&lt;code&gt;UIKit Peek &amp;amp; Pop&lt;/code&gt; 、&lt;code&gt;WebView Peek &amp;amp; Pop&lt;/code&gt; 和&lt;code&gt;UITouch Force Properties&lt;/code&gt;）用于操作3D Touch(&lt;code&gt;Pressure Sensitivity&lt;/code&gt; 、 &lt;code&gt;Peek and Pop&lt;/code&gt; 和 &lt;code&gt;Quick Actions&lt;/code&gt;)。不过无论使用哪一种API，首先需要做的事情是检查3D Touch是否可用。&lt;/p&gt;

&lt;h3&gt;检测是否支持3D Touch&lt;/h3&gt;

&lt;p&gt;在iOS9中提供如下的接口用于检查设备是否支持3D Touch：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@property(nonatomic, readonly) UIForceTouchCapability forceTouchCapability;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;其中&lt;code&gt;UIForceTouchCapability&lt;/code&gt;是一个枚举类型，具体的描述情况如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UIForceTouchCapability

&lt;ul&gt;
&lt;li&gt;UIForceTouchCapabilityUnknown         //3D Touch检测失败&lt;/li&gt;
&lt;li&gt;UIForceTouchCapabilityUnavailable     //3D Touch不可用&lt;/li&gt;
&lt;li&gt;UIForceTouchCapabilityAvailable       //3D Touch可用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这3个枚举值就是我们来判断设备是否开启3D Touch功能，可以在UIViewController生命周期的viewWillAppear中做如下判断：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) {
    //do something
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当然在生命周期内，如果用户有意修改了设备的3D Touch功能，我们还有一个地方来重新检测：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)traitCollectionDidChange:(UITraitCollection *)previousTraitCollection {
    //do something
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;Home Screen Quick Action&lt;/h4&gt;

&lt;p&gt;在iPhone 6s或者iPhone 6s Plus上面，当用户按压App的Icon图标的时候，会弹出Quick Action，当用户选择其中的Action的时候，App会启动并实现相应的功能。这一过程相当于在PC上面的右键快捷菜单的功能，如下图所示的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios9_3d_touch/maps_directions_home_2x.png&quot; alt=&quot;maps_directions_home&quot;&gt;&lt;/p&gt;

&lt;h4&gt;开发环境&lt;/h4&gt;

&lt;p&gt;官方文档上指出Xcode7.0以上的模拟器不支持3D Touch，必须使用支持3D Touch的设备（iPhone 6s或者iPhone 6s Plus）进行调试。但是这并不能阻止我们在模拟器上面进行调试，GitHub上面早有大神提供了模拟器调试Quick Action的方法，项目的地址是：&lt;code&gt;https://github.com/DeskConnect/SBShortcutMenuSimulator&lt;/code&gt;。下面简单介绍一下安装的步骤：&lt;/p&gt;

&lt;h5&gt;①编译&lt;/h5&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git clone https://github.com/DeskConnect/SBShortcutMenuSimulator.git
cd SBShortcutMenuSimulat
make
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h5&gt;②让SpringBoard支持SBShortcutMenuSimulator&lt;/h5&gt;

&lt;p&gt;在开启模拟器的情况下，在SBShortcutMenuSimulator目录下面执行如下两行命令：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;xcrun simctl spawn booted launchctl debug system/com.apple.SpringBoard --environment DYLD_INSERT_LIBRARIES=$PWD/SBShortcutMenuSimulator.dylib
xcrun simctl spawn booted launchctl stop com.apple.SpringBoard
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h5&gt;③预览效果&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;echo &amp;#39;com.apple.mobilecal&amp;#39; | nc 127.0.0.1 8000&lt;/code&gt;，其中com.apple.mobilecal指的是系统自带的日历的Bundle ID，运行的时候替换成你的应用的Bundle ID即可。&lt;/p&gt;

&lt;h4&gt;创建方式&lt;/h4&gt;

&lt;p&gt;上面的示例图中有四个Action Item，其中每个Action是使用UIApplicationShortcutItem这个对象进行描述的，下面列出每一个UIApplicationShortcutItem中能够包含的信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios9_3d_touch/action_item_desc.png&quot; alt=&quot;action_item_desc.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;创建Quick Action有两种方式：静态和动态&lt;/p&gt;

&lt;h5&gt;①以静态方式创建&lt;/h5&gt;

&lt;p&gt;静态创建的方式是在Info.plist文件中进行声明的&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;&amp;lt;key&amp;gt;UIApplicationShortcutItems&amp;lt;/key&amp;gt;
&amp;lt;array&amp;gt;
    &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;UIApplicationShortcutItemType&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;com.devzeng.homePage&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;UIApplicationShortcutItemTitle&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;首页&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;UIApplicationShortcutItemSubtitle&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;这是首页&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;UIApplicationShortcutItemIconFile&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;icon_home.png&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;UIApplicationShortcutItemUserInfo&amp;lt;/key&amp;gt;
        &amp;lt;dict&amp;gt;
            &amp;lt;key&amp;gt;scheme&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;devzeng://home&amp;lt;/string&amp;gt;
        &amp;lt;/dict&amp;gt;
    &amp;lt;/dict&amp;gt;
    &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;UIApplicationShortcutItemType&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;com.devzeng.about&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;UIApplicationShortcutItemTitle&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;关于我们&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;UIApplicationShortcutItemSubtitle&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;这是关于我们&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;UIApplicationShortcutItemIconFile&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;icon_about.png&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;UIApplicationShortcutItemUserInfo&amp;lt;/key&amp;gt;
        &amp;lt;dict&amp;gt;
            &amp;lt;key&amp;gt;scheme&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;devzeng://about&amp;lt;/string&amp;gt;
        &amp;lt;/dict&amp;gt;
    &amp;lt;/dict&amp;gt;
&amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h5&gt;②以动态方式创建&lt;/h5&gt;

&lt;p&gt;动态创建是在程序初始化的时候用代码动态添加。&lt;code&gt;UIApplication&lt;/code&gt;对象多了一个支持快捷方式的数组（shortcutItems）, 如果需要增加快捷方式，可以赋值给shortcutItems属性。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@property(nonatomic, copy) NSArray &amp;lt;UIApplicationShortcutItem *&amp;gt; *shortcutItems;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;//创建ShortcutItem
UIApplicationShortcutIcon *icon1 = [UIApplicationShortcutIcon iconWithTemplateImageName:@&amp;quot;icon_register.png&amp;quot;];//创建快捷item的icon即UIApplicationShortcutItemIconFile
NSDictionary *info1 = @{@&amp;quot;scheme&amp;quot;:@&amp;quot;devzeng://register&amp;quot;};//创建快捷item的userinfo即UIApplicationShortcutItemUserInfo
UIMutableApplicationShortcutItem *item1 = [[UIMutableApplicationShortcutItem alloc] initWithType:@&amp;quot;com.devzeng.registerPage&amp;quot; localizedTitle:@&amp;quot;注册&amp;quot; localizedSubtitle:@&amp;quot;注册新用户&amp;quot; icon:icon1 userInfo:info1];
//创建ShortcutItem
UIApplicationShortcutIcon *icon2 = [UIApplicationShortcutIcon iconWithTemplateImageName:@&amp;quot;icon_shop.png&amp;quot;];
NSDictionary *info2 = @{@&amp;quot;scheme&amp;quot;:@&amp;quot;devzeng://shop&amp;quot;};
UIMutableApplicationShortcutItem *item2 = [[UIMutableApplicationShortcutItem alloc] initWithType:@&amp;quot;com.devzeng.shopPage&amp;quot; localizedTitle:@&amp;quot;购物车&amp;quot; localizedSubtitle:@&amp;quot;查看购物车&amp;quot; icon:icon2 userInfo:info2];
//创建ShortcutItem
UIApplicationShortcutIcon *icon3 = [UIApplicationShortcutIcon iconWithTemplateImageName:@&amp;quot;icon_help.png&amp;quot;];
NSDictionary *info3 = @{@&amp;quot;scheme&amp;quot;:@&amp;quot;devzeng://help&amp;quot;};
UIMutableApplicationShortcutItem *item3 = [[UIMutableApplicationShortcutItem alloc] initWithType:@&amp;quot;com.devzeng.helpPage&amp;quot; localizedTitle:@&amp;quot;帮助&amp;quot; localizedSubtitle:@&amp;quot;帮助手册&amp;quot; icon:icon3 userInfo:info3];
//注册ShortcutItem
[UIApplication sharedApplication].shortcutItems = items;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;1)系统限制每个App最多能够显示4个Action Item，其中包括静态方式和动态方式进行创建的；&lt;/p&gt;

&lt;p&gt;2)如果静态和动态方式同时使用的时候，给UIApplication的shortcutItems赋值的时候不会覆盖&lt;/p&gt;

&lt;h4&gt;响应回调&lt;/h4&gt;

&lt;p&gt;当app在后台的时候UIApplication提供了一个回调方法&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void(^)(BOOL succeeded))completionHandler NS_AVAILABLE_IOS(9_0);
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我们依据这个回调中的shortcutItem的type和userinfo来做出不同的事件处理,而最后的completionHandler在API的说明中我们看到当应用并非在后台，而是直接重新开进程的时候，直接返回No，那么这个时候，我们的回调会放在&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;UIApplication又给我们一个从launchOptions中获取这个shortcutItem的key(UIApplicationLaunchOptionsShortcutItemKey)&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;UIApplicationShortcutItem *item = [launchOptions valueForKey:UIApplicationLaunchOptionsShortcutItemKey];
//根据不同的Action响应不同的事件
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在performActionForShortcutItem回调中&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)application:(UIApplication *)application performActionForShortcutItem:(UIApplicationShortcutItem *)shortcutItem completionHandler:(void(^)(BOOL succeeded))completionHandler {
    if (shortcutItem) {
        //根据不同的Action响应不同的事件
    }
    if (completionHandler) {
        completionHandler(YES);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;UIKit Peek &amp;amp; Pop&lt;/h4&gt;

&lt;p&gt;Peek和Pop手势给了iOS9用户预览和体验内容的全新方法。iPhone6s/iPhone6s Plus可通过用户触摸力度感知需求，并给出更加丰富的操作选项。目前这项功能已经在邮件、照片、日历等应用中启用。&lt;/p&gt;

&lt;p&gt;根据苹果的介绍，Peek手势允许用户通过短时间按压屏幕进行操作，可在邮件、照片等应用弹出全新功能菜单，给出预览内容。如果按压力度加大，则是Pop手势功能，会让被点击内容完全呈现，这些内容可以是文字、图像、网页以及其他各种内容。简单来说，Peek专注于预览，Pop可以全面展现内容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios9_3d_touch/peek_2x.png&quot; alt=&quot;peek_2x.png&quot;&gt;&lt;/p&gt;

&lt;h5&gt;1、检测3D Touch是否可用，如果可用就注册&lt;/h5&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)check3DTouchAvailable {
    // 如果开启了3D touch，注册
    if (self.traitCollection.forceTouchCapability == UIForceTouchCapabilityAvailable) {
        [self registerForPreviewingWithDelegate:(id)self sourceView:_label];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h5&gt;2、实现UIViewControllerPreviewingDelegate的Protocol&lt;/h5&gt;

&lt;p&gt;①Peek手势相关处理:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (UIViewController *)previewingContext:(id&amp;lt;UIViewControllerPreviewing&amp;gt;)context viewControllerForLocation:(CGPoint)point {
    //防止重复加入
    if ([self.presentedViewController isKindOfClass:[PeekDemoViewController class]]){
        return nil;
    }
    else {
        PeekDemoViewController *peekViewController = [[PeekDemoViewController alloc] init];
        return peekViewController;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在PeekDemoViewController中添加previewActionItems：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (NSArray&amp;lt;id&amp;lt;UIPreviewActionItem&amp;gt;&amp;gt; *)previewActionItems {

    // 生成UIPreviewAction
    UIPreviewAction *action1 = [UIPreviewAction actionWithTitle:@&amp;quot;Action 1&amp;quot; style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) {
        NSLog(@&amp;quot;Action 1 selected&amp;quot;);
    }];

    UIPreviewAction *action2 = [UIPreviewAction actionWithTitle:@&amp;quot;Action 2&amp;quot; style:UIPreviewActionStyleDestructive handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) {
        NSLog(@&amp;quot;Action 2 selected&amp;quot;);
    }];

    UIPreviewAction *action3 = [UIPreviewAction actionWithTitle:@&amp;quot;Action 3&amp;quot; style:UIPreviewActionStyleSelected handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) {
        NSLog(@&amp;quot;Action 3 selected&amp;quot;);
    }];

    UIPreviewAction *tap1 = [UIPreviewAction actionWithTitle:@&amp;quot;tap 1&amp;quot; style:UIPreviewActionStyleDefault handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) {
        NSLog(@&amp;quot;tap 1 selected&amp;quot;);
    }];

    UIPreviewAction *tap2 = [UIPreviewAction actionWithTitle:@&amp;quot;tap 2&amp;quot; style:UIPreviewActionStyleDestructive handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) {
        NSLog(@&amp;quot;tap 2 selected&amp;quot;);
    }];

    UIPreviewAction *tap3 = [UIPreviewAction actionWithTitle:@&amp;quot;tap 3&amp;quot; style:UIPreviewActionStyleSelected handler:^(UIPreviewAction * _Nonnull action, UIViewController * _Nonnull previewViewController) {
        NSLog(@&amp;quot;tap 3 selected&amp;quot;);
    }];

    //添加到到UIPreviewActionGroup中
    NSArray *actions = @[action1, action2, action3];
    NSArray *taps = @[tap1, tap2, tap3];
    UIPreviewActionGroup *group1 = [UIPreviewActionGroup actionGroupWithTitle:@&amp;quot;Action Group&amp;quot; style:UIPreviewActionStyleDefault actions:actions];
    UIPreviewActionGroup *group2 = [UIPreviewActionGroup actionGroupWithTitle:@&amp;quot;Tap Group&amp;quot; style:UIPreviewActionStyleDefault actions:taps];
    NSArray *group = @[group1,group2];

    return group;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/images/ios9_3d_touch/peek_quick_actions_2x.png&quot; alt=&quot;peek_quick_actions_2x.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;②Pop手势相关处理:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)previewingContext:(id&amp;lt;UIViewControllerPreviewing&amp;gt;)previewingContext commitViewController:(UIViewController *)viewControllerToCommit {
    PopDemoViewController *popViewController = [[PopDemoViewController alloc] init];
    [self showViewController:popViewController sender:self];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;1.&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/&quot;&gt;《Adopting 3D Touch on iPhone》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;http://pingguohe.net/2015/10/08/3D-Touch-1.html&quot;&gt;《浅谈3D Touch（1） -- Home screen quick action》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;http://pingguohe.net/2015/10/12/3D-Touch-2.html&quot;&gt;《浅谈3D Touch（2） -- UITouch &amp;amp;&amp;amp; Peek &amp;amp;&amp;amp; Pop》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;http://www.allenchiang.com/2015/09/21/%E9%80%82%E9%85%8D3d-touch%E4%B9%8Bquick-actions/&quot;&gt;《适配3d-touch》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.&lt;a href=&quot;http://www.stringcode.co.uk/add-ios-9s-quick-actions-shortcut-support-in-15-minutes-right-now/?utm_campaign=iOS%2BDev%2BWeekly&amp;amp;utm_medium=email&amp;amp;utm_source=iOS_Dev_Weekly_Issue_216&quot;&gt;《Add iOS 9’s Quick Actions shortcut support in 15 minutes right now !》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6.&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NDMzMTcxMg==&amp;amp;mid=212175593&amp;amp;idx=1&amp;amp;sn=887118aaa63d4d364ccf16be9e807a72#rd&quot;&gt;《15分钟搞定iOS9 Quick Actions》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.&lt;a href=&quot;http://szulctomasz.com/3d-touch-impressions-and-thoughts/&quot;&gt;《iOS: 3D Touch, impressions and thoughts》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8.&lt;a href=&quot;http://swift.gg/2015/10/23/3d-touch-impressions-and-thoughts/&quot;&gt;《3D Touch之我见》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Oct 2015 21:19:25 +0800</pubDate>
        <link>http://blog.devzeng.com/ios9-3d-touch.html</link>
        <guid isPermaLink="true">http://blog.devzeng.com/ios9-3d-touch.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>在iOS9中使用CoreSpotlight</title>
        <description>&lt;p&gt;在iOS9之前，用户可以通过Spotlight中输入关键字来查找App。在iOS9中Apple随之发布了一套全新的iOS9 Search APIs之后，开发者不但可以自由的将App的部分内容建立索引，还能对Spotlight上的搜索结果以及点击不同的结果显示的内容进行设置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios9_corespotlight/apple_search_demo.png&quot; alt=&quot;apple_search_demo.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;三种搜索的API简介&lt;/h3&gt;

&lt;h4&gt;NSUserActivity&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;NSUserActivity&lt;/code&gt;是iOS8专为Handoff推出的API，在iOS9得到了提升。现在用户只需要提供元数据(metadata)就能搜索到不同的活动(Activity)了。也就是说Spotlight可以将Activity加入到索引，而NSUserActivity就好比网页浏览器的历史堆栈(history stack, 可以理解为最近使用的App，或者是近期常用联系人等)，用户可以通过Spotlight搜索到最近的Activity.&lt;/p&gt;

&lt;h4&gt;Web Markup&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Web Markup&lt;/code&gt;在网页上显示App的内容并建立Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。&lt;/p&gt;

&lt;h4&gt;CoreSpotlight&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;NSUserActivity&lt;/code&gt;帮助储存用户历史，而全新的&lt;code&gt;CoreSpotlight&lt;/code&gt;则能为App中的任何内容创建索引，实质是在用户设备上提供基础的&lt;code&gt;CoreSpotlight&lt;/code&gt;索引渠道，满足用户另外一个需求。最典型的一个例子是印象笔记和iOS自带的Note，用户无需打开对应的App通过Spotlight就能搜索到笔记的内容，然后快速打开。&lt;/p&gt;

&lt;h3&gt;使用CoreSpotlight APIs&lt;/h3&gt;

&lt;h4&gt;1、引入CoreSpotlight.framework&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios9_corespotlight/corespotlight_framework.png&quot; alt=&quot;corespotlight_framework&quot;&gt;&lt;/p&gt;

&lt;h4&gt;2、创建索引&lt;/h4&gt;

&lt;h5&gt;（1）创建索引所需的元数据&lt;/h5&gt;

&lt;p&gt;为了让内容可以被搜索，首先需要创建一个包含元数据的属性&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios9_corespotlight/searchable_attributes.png&quot; alt=&quot;searchable_attributes.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;CSSearchableItemAttributeSet *attributeSet = [[CSSearchableItemAttributeSet alloc] initWithItemContentType:@&amp;quot;contact&amp;quot;];
attributeSet.title = @&amp;quot;标题&amp;quot;;
attributeSet.contentDescription = @&amp;quot;内容&amp;quot;;
attributeSet.keywords = @[@&amp;quot;关键字1&amp;quot;, @&amp;quot;关键字2&amp;quot;];
attributeSet.thumbnailData = UIImagePNGRepresentation([UIImage imageNamed:@&amp;quot;缩略图&amp;quot;]);
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h5&gt;（2）创建索引&lt;/h5&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;CSSearchableItem *searchableItem = [[CSSearchableItem alloc] initWithUniqueIdentifier:@&amp;quot;&amp;quot; domainIdentifier:@&amp;quot;&amp;quot; attributeSet:attributeSet];
searchableItem.expirationDate = [NSDate dateWithTimeIntervalSinceNow:3600];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;1)uniqueIdentifier:在应用程序中这个值是唯一的，由于这个可以用于索引的更新、删除索引是唯一的，推荐使用UUID或者是搜索的条目的主键。&lt;/p&gt;

&lt;p&gt;2)domainIdentifier:一个可选的标识符，用来表示item的域(domain)或者所有者，这个可能用一个账户的邮箱作为identifier来索引数据，并且当账户删除的时候可以根据这个来删除数据，一般情况下domainIdentifier应该是这种格式&lt;account-id&gt;.&lt;mailbox-id&gt;并且不能包含时间。&lt;/p&gt;

&lt;p&gt;3)expirationDate:过期的日期，默认过期的日期是一个月&lt;/p&gt;

&lt;h5&gt;（3）将索引加入到CoreSpotlight&lt;/h5&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[[CSSearchableIndex defaultSearchableIndex] indexSearchableItems:@[searchableItem] completionHandler:^(NSError * _Nullable error) {
    if(error) {
        NSLog(@&amp;quot;%@&amp;quot;, [error localizedDescription]);
    }
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;3、配置用户点击搜索结果的处理动作&lt;/h4&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void(^)(NSArray * __nullable restorableObjects))restorationHandler {
    if([userActivity.activityType isEqualToString:CSSearchableItemActionType]) {
        NSString *uniqueIdentifier = userActivity.userInfo[CSSearchableItemActivityIdentifier];
        //这里根据这个uniqueIdentifier可以跳转到详细信息页面
        return YES;
    }
    return YES;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/AppSearch/index.html&quot;&gt;《App Search Programming Guide》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;https://www.shinobicontrols.com/blog/ios9-day-by-day-day1-search-apis&quot;&gt;《iOS9 Day-by-Day :: Day 1 :: Search APIs》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://blog.csdn.net/mengxiangyue/article/details/46575977&quot;&gt;《CoreSpotlight.framework注释翻译》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Oct 2015 16:37:38 +0800</pubDate>
        <link>http://blog.devzeng.com/ios9-corespotlight.html</link>
        <guid isPermaLink="true">http://blog.devzeng.com/ios9-corespotlight.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>使用SQLCipher加密SQLite数据库</title>
        <description>&lt;p&gt;在iOS应用程序开发中经常需要使用SQLite来存储数据，很多时候需要加密保存一部分的数据。常见的做法是将要存储的内容先加密然后存到数据库中，使用的时候将数据进行解密，这样就会有大量的性能消耗在数据的加解密上（性能主要取决于加解密的算法和CPU的能力）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;SQLCipher is an open source extension to SQLite that provides transparent 256-bit AES encryption of database files.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SQLite本身是支持加密功能的（免费版本不提供加密功能，商业版本是支持加密模块）。SQLCipher是一个开源的SQLite加密扩展，支持对db文件进行256位的AES加密。&lt;/p&gt;

&lt;h3&gt;集成SQLCipher&lt;/h3&gt;

&lt;p&gt;集成SQLCipher有有两种方法一种是按照&lt;a href=&quot;https://www.zetetic.net/sqlcipher/ios-tutorial/&quot;&gt;官方&lt;/a&gt;的方式一步步的执行，这里就不过多的介绍。配置过程很麻烦，推荐使用下面的方式集成。&lt;/p&gt;

&lt;p&gt;1、获取SQLite加密模块(SQLCipher)&lt;/p&gt;

&lt;p&gt;在终端(Terminal)中使用&lt;code&gt;pod search FMDB&lt;/code&gt;，在查询的结果中可以看到有个&lt;code&gt;FMDB/SQLCipher&lt;/code&gt;的Sub spec。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sqlcipher-sqlite/sqlcipher-search-fmdb.png&quot; alt=&quot;sqlcipher-search-fmdb.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果使用FMDB和CocoaPods的话直接在你的Podfile中添加&lt;code&gt;pod &amp;#39;FMDB/SQLCipher&amp;#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sqlcipher-sqlite/sqlcipher-podfile.png&quot; alt=&quot;sqlcipher-podfile.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果没有使用CocoaPods的话建议还是安装一个吧，或者是新建一个测试项目安装FMDB和SQLCipher。安装CocoaPods可以参考&lt;a href=&quot;http://blog.devzeng.com/blog/ios-cocoapods-dependency-manager.html&quot;&gt;《使用CocoaPods管理iOS项目中的依赖库》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、导入SQLCipher&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;pod install&lt;/code&gt;之后会自动获取SQLCipher，其实SQLCipher只有两个文件&lt;code&gt;sqlite3.h&lt;/code&gt;和&lt;code&gt;sqlite3.m&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;拷贝sqlite3.h/sqlite3.m文件到项目中，如果使用CocoaPods方式获取SQLCipher的话，这一步骤就不需要了。&lt;/p&gt;

&lt;p&gt;3、配置Xcode设置项&lt;/p&gt;

&lt;p&gt;通过查询资料SQLite是否开启加密模块是通过宏(&lt;code&gt;SQLITE_HAS_CODEC&lt;/code&gt;)来配置的。那么就需要在Xcode中配置开启SQLite加密组件的宏（如使用CocoaPods方式则不需要配置）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sqlcipher-sqlite/sqlite-extension-marco.png&quot; alt=&quot;sqlite-extension-marco.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(1)target -&amp;gt; Build Setting -&amp;gt; Other C Flags添加-DSQLITE_HAS_CODEC、-DSQLITE_TEMP_STORE=2、-DSQLITE_THREADSAFE、-DSQLCIPHER_CRYPTO_CC几项配置&lt;/p&gt;

&lt;p&gt;(2)target -&amp;gt; Build Setting -&amp;gt; Other Linker Flags添加-framework Security配置&lt;/p&gt;

&lt;p&gt;4、如何使用&lt;/p&gt;

&lt;p&gt;(1)引入sqlite3加密模块，然后在打开数据库之后加入如下代码&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;const char *key = [@&amp;quot;devzeng&amp;quot; UTF8String];
sqlite3_key(_db, key, (int)strlen(key));
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sqlcipher-sqlite/sqlcipher-sqlite3-open.png&quot; alt=&quot;sqlcipher-sqlite3-open.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;1）如果没有添加-DSQLITE_HAS_CODEC配置上面的代码会报错&lt;/p&gt;

&lt;p&gt;2）sqlite3_key函数需要指定加密使用的key，推荐使用UUID(可以进行salt处理)并存储到KeyChain中。&lt;/p&gt;

&lt;p&gt;3）如使用FMDB，可以在FMDB的open方法之后添加上面的两行代码。&lt;/p&gt;

&lt;p&gt;(2)使用了加密模块在提交到App Store时需要指明，具体的操作方法可以参考StackOverflow上面的做法。
&lt;a href=&quot;http://stackoverflow.com/questions/2135081/does-my-application-contain-encryption&quot;&gt;Does my application “contain encryption”?&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;https://www.zetetic.net/sqlcipher/ios-tutorial/&quot;&gt;《Adding SQLCipher to Xcode Projects》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.2cto.com/kf/201407/315727.html&quot;&gt;《ios开发FMDB导入SQLCipher加密数据库》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://blog.itpub.net/14466241/viewspace-752861/&quot;&gt;《SQLite数据库加密研究》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 19 Jul 2015 20:02:54 +0800</pubDate>
        <link>http://blog.devzeng.com/encrypt-sqlite-with-sqlcipher.html</link>
        <guid isPermaLink="true">http://blog.devzeng.com/encrypt-sqlite-with-sqlcipher.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS中Realm数据库的基本用法</title>
        <description>&lt;p&gt;Realm是由&lt;code&gt;Y Combinator&lt;/code&gt;公司孵化的一款支持运行在手机、平板和可穿戴设备上的嵌入式数据库（旨在取代CoreData和Sqlite）。Realm并不是对Core Data的简单封装，相反地，Realm并不是基于Core Data，也不是基于SQLite所构建的。它拥有自己的数据库存储引擎，可以高效且快速地完成数据库的构建操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/realm_usage/hello_realm.png&quot; alt=&quot;hello_realm.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;Realm可以轻松地移植到项目当中，并且绝大部分常用的功能（比如说插入、查询等等）都可以用一行简单的代码轻松完成！目前支持Objective-C、Swift和Java三种语言，也就是说能在iOS、Android和Mac上面跨平台使用。&lt;/p&gt;

&lt;p&gt;综上，Realm主要有以下几个优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Easy to Use(简单易用)：Core Data和SQLite冗余、繁杂的知识和代码足以吓退绝大多数刚入门的开发者，而换用Realm，则可以极大地减少学习代价和学习时间，让应用及早用上数据存储功能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cross-Platform(跨平台)：现在绝大多数的应用开发并不仅仅只在iOS平台上进行开发，还要兼顾到Android平台的开发。为两个平台设计不同的数据库是愚蠢的，而使用Realm数据库，iOS和Android无需考虑内部数据的架构，调用Realm提供的API就可以完成数据的交换，实现“一个数据库，两个平台无缝衔接”。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fast(高效)：Realm相比使用CoreData和原生的SQLite来说速度更快更加高效，而且代码量更少。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;快速集成Realm&lt;/h3&gt;

&lt;p&gt;1、下载最新的&lt;a href=&quot;http://realm.io&quot;&gt;Realm&lt;/a&gt;更新包，解压zip文件&lt;/p&gt;

&lt;p&gt;2、将&lt;code&gt;ios/static&lt;/code&gt;目录下面的&lt;code&gt;Realm.framework&lt;/code&gt;文件拖到项目里面（确保Copy items if needed选中）&lt;/p&gt;

&lt;p&gt;3、在&lt;code&gt;target -&amp;gt; Build Phases -&amp;gt; Link Binary with Libraries&lt;/code&gt;中添加&lt;code&gt;libc++.dylib&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;（1）对于使用Swift的童鞋，请讲Swift/RLMSupport.swift文件拖到项目中（确保Copy items if needed选中）&lt;/p&gt;

&lt;p&gt;（2）推荐使用Cocoapods进行安装，在Podfile中添加&lt;code&gt;pod &amp;#39;Realm&amp;#39;&lt;/code&gt;即可&lt;/p&gt;

&lt;p&gt;（3）也可以自行到Github上面下载代码进行编译，此处不作过多的介绍&lt;/p&gt;

&lt;p&gt;运行环境：&lt;/p&gt;

&lt;p&gt;（1）支持 &amp;gt;= iOS7.0, &amp;gt;= OS X 10.9, 及WatchKit&lt;/p&gt;

&lt;p&gt;（2）推荐使用Xcode 5以上的IDE，支持Swift&lt;/p&gt;

&lt;h3&gt;辅助工具和插件的安装&lt;/h3&gt;

&lt;h4&gt;1、Realm Browser&lt;/h4&gt;

&lt;p&gt;Realm官方非常贴心的向开发者提供了一个用于查看喝编辑Realm数据的工具&lt;code&gt;Realm Browser&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/realm_usage/browser.png&quot; alt=&quot;browser.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;在上面下载的更新包的&lt;code&gt;browser/&lt;/code&gt;下面有个Realm Browser拖到Application文件夹或者是直接打开都行。另外可以使用菜单的&lt;code&gt;tool -&amp;gt; generate demo datebase&lt;/code&gt;,生成测试数据用于测试Realm数据库的使用&lt;/p&gt;

&lt;h4&gt;2、Xcode Plugin&lt;/h4&gt;

&lt;p&gt;在Realm中使用到最多的是Realm Model(继承自RLMObject的类，后面有介绍)。官方提供了一个Xcode的插件让我们在创建模型变得非常轻松&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/realm_usage/plugin.png&quot; alt=&quot;plugin.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;安装使用：&lt;/p&gt;

&lt;p&gt;（1）最简单的安装方式是通过Alcatraz,搜索&lt;code&gt;RealmPlugin&lt;/code&gt;直接安装&lt;/p&gt;

&lt;p&gt;（2）或者是打开zip文件夹下面的&lt;code&gt;plugin/RealmPlguin.xcodeproj&lt;/code&gt;,build一下就安装好了&lt;/p&gt;

&lt;p&gt;安装完后重启Xcode生效，在创建model的时候选择New File(或⌘N)，选择Realm按照要求输入model的名字就OK啦。&lt;/p&gt;

&lt;h3&gt;Realm的使用&lt;/h3&gt;

&lt;h4&gt;1、构建数据库&lt;/h4&gt;

&lt;p&gt;Realm提供了三种方式创建数据库，一种是存储在默认路径下的数据库，一种是我们可以自己指定数据库文件的存储路径和只读属性，另外还可以使用内存数据库。&lt;/p&gt;

&lt;p&gt;（1）默认Realm数据库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RLMRealm *realm = [RLMRealm defaultRealm];&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以通过：&lt;code&gt;[RLMRealm defaultRealmPath]&lt;/code&gt;查看默认存储的路径。&lt;/p&gt;

&lt;p&gt;（2）自定义Realm数据库&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
NSString *dbPath = [docPath stringByAppendingPathComponent:@&amp;quot;db/db.realm&amp;quot;];
RLMRealm *realm = [RLMRealm realmWithPath:dbPath];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;或者是&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NSString *docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
NSString *dbPath = [docPath stringByAppendingPathComponent:@&amp;quot;db/db.realm&amp;quot;];
RLMRealm *realm = [RLMRealm realmWithPath:dbPath readOnly:YES error:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;其中readOnly表示创建的数据库是只读数据库。&lt;/p&gt;

&lt;p&gt;（3）内存数据库&lt;/p&gt;

&lt;p&gt;正常的Realm数据库是存储在硬盘上的， 但你也可以通过使用&lt;code&gt;+ (instancetype)inMemoryRealmWithIdentifier:(NSString *)identifier;&lt;/code&gt;来创建一个内存数据库。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;RLMRealm *realm = [RLMRealm inMemoryRealmWithIdentifier:@&amp;quot;test&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;注意：内存数据库在每次程序退出时不会保存数据。如果某个内存Realm实例没有被引用，所有的数据在实例对象释放的适合也会被释放。建议你在app中用强引用来钳制所有新建的内存Realm数据库实例。&lt;/p&gt;

&lt;h4&gt;2、数据模型&lt;/h4&gt;

&lt;p&gt;Realm的数据模型是用传统的Objective-C接口（interface）和属性（@property）定义的。 只要定义 &lt;code&gt;RLMObject&lt;/code&gt;的一个子类或者一个现成的模型类，你就能轻松创建一个Realm的数据模型对象。Realm模型对象和其他的Objective-c的功能很相似–你可以给它们添加你自己的方法和protocol然后和其他的对象一样使用。 唯一的限制就是从它们被创建开始，只能在一个进程中被使用。&lt;/p&gt;

&lt;p&gt;如果已经安装了Realm Xcode插件，在&lt;code&gt;New File&lt;/code&gt;对话框中会有一个很漂亮的样板，你可以用它来创建interface和implementation文件。&lt;/p&gt;

&lt;p&gt;用一个对象来表示一篇文章（Articl）,创建的数据模型如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Article.h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@interface Article : RLMObject

@property NSString *num;//序号
@property NSString *title;//标题
@property NSString *link;//链接地址
@property NSString *author;//作者
@property NSString *tag;//标签分类
@property NSInteger weight;//权重

@end

RLM_ARRAY_TYPE(Article)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Article.m&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@implementation Article

//主键
+ (NSString *)primaryKey {
    return @&amp;quot;num&amp;quot;;
}

//需要添加索引的属性
+ (NSArray *)indexedProperties {
    return @[@&amp;quot;title&amp;quot;];
}

//默认属性值
+ (NSDictionary *)defaultPropertyValues {
    return @{@&amp;quot;author&amp;quot;:@&amp;quot;zengjing&amp;quot;};
}

//忽略的字段
+ (NSArray *)ignoredProperties {
    return @[@&amp;quot;weight&amp;quot;];
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;（1）Realm支持以下的属性（property）种类：BOOL, bool, int, NSInteger, long, float, double, CGFloat, NSString, NSDate 和 NSData。&lt;/p&gt;

&lt;p&gt;（2）你可以使用&lt;code&gt;RLMArray&amp;lt;Object&amp;gt;&lt;/code&gt;和&lt;code&gt;RLMObject&lt;/code&gt;来模拟对一或对多的关系(Realm也支持RLMObject继承)&lt;/p&gt;

&lt;p&gt;（3）Realm忽略了Objective-C的property attributes(如nonatomic, atomic, strong, copy, weak 等等）。 所以，推荐在创建模型的时候不要使用任何的property attributes。但是，假如你设置了，这些attributes会一直生效直到RLMObject被写入realm数据库。&lt;/p&gt;

&lt;p&gt;（4）定义了&lt;code&gt;RLM_ARRAY_TYPE(Article)&lt;/code&gt;这个宏表示支持&lt;code&gt;RLMArray&amp;lt;Article&amp;gt;&lt;/code&gt;该属性&lt;/p&gt;

&lt;p&gt;（5）另外Realm提供了以下几个方法供对属性进行自定义：&lt;/p&gt;

&lt;p&gt;1）&lt;code&gt;+ (NSArray *)indexedProperties;&lt;/code&gt;: 可以被重写来来提供特定属性（property）的属性值（attrbutes）例如某个属性值要添加索引。&lt;/p&gt;

&lt;p&gt;2）&lt;code&gt;+ (NSDictionary *)defaultPropertyValues;&lt;/code&gt;: 为新建的对象属性提供默认值。&lt;/p&gt;

&lt;p&gt;3）&lt;code&gt;+ (NSString *)primaryKey;&lt;/code&gt;: 可以被重写来设置模型的主键。定义主键可以提高效率并且确保唯一性。&lt;/p&gt;

&lt;p&gt;4）&lt;code&gt;+ (NSArray *)ignoredProperties;&lt;/code&gt;：可以被重写来防止Realm存储模型属性。&lt;/p&gt;

&lt;h4&gt;3、数据增删改查&lt;/h4&gt;

&lt;p&gt;（1）存储数据&lt;/p&gt;

&lt;p&gt;创建数据模型对象：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Article *article = [[Article alloc] init];
article.num      = @&amp;quot;1&amp;quot;;
article.title    = @&amp;quot;iOS开发中集成Reveal&amp;quot;;
article.link     = @&amp;quot;http://blog.devzeng.com/blog/ios-reveal-integrating.html&amp;quot;;
article.tag      = @&amp;quot;iOS&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;存储数据：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;RLMRealm *realm = [RLMRealm defaultRealm];
[realm beginWriteTransaction];
[realm addObject:article];
[realm commitWriteTransaction];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;（2）删除数据&lt;/p&gt;

&lt;p&gt;1）删除指定的数据：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;- (void)deleteObject:(RLMObject *)object;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2）删除一组数据：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;- (void)deleteObjects:(id)array;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3）删除全部的数据：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;- (void)deleteAllObjects;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;（3）修改数据&lt;/p&gt;

&lt;p&gt;修改数据如果该条数据不存在则会新建一条数据。&lt;/p&gt;

&lt;p&gt;1）针对单个数据进行的修改或新增：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;- (void)addOrUpdateObject:(RLMObject *)object;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2）针对一组数据的修改或新增：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;- (void)addOrUpdateObjectsFromArray:(id)array;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;说明：对于增加、删除、修改必须要在事务中进行操作。&lt;/p&gt;

&lt;p&gt;（5）查询数据&lt;/p&gt;

&lt;p&gt;1）查询全部数据&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;RLMResults *results = [Article allObjects];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;或指定Realm数据库：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NSString *path = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
NSString *realmPath = [path stringByAppendingPathComponent:@&amp;quot;devzeng.realm&amp;quot;];
RLMRealm *realm = [RLMRealm realmWithPath:realmPath];
RLMResults *results = [Article allObjectsInRealm:realm];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;2）条件查询&lt;/p&gt;

&lt;p&gt;假设要查询所有分组是iOS和作者是zengjing的文章：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;RLMResults *results = [Article objectsWhere:@&amp;quot;tag = &amp;#39;iOS&amp;#39; AND author = &amp;#39;zengjing&amp;#39;&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;也可以使用谓词查询：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;NSPredicate *pred = [NSPredicate predicateWithFormat:@&amp;quot;tag = &amp;#39;%@&amp;#39; AND author = &amp;#39;%@&amp;#39;&amp;quot;, @&amp;quot;iOS&amp;quot;, @&amp;quot;zengjing&amp;quot;];
RLMResults *results = [Article objectsWithPredicate:pred];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;3）条件排序&lt;/p&gt;

&lt;p&gt;假设要查询所有分组是iOS和作者是zengjing的文章，然后筛选出来的结果按照num字段进行递增排序：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;RLMResults *results = [[Article objectsWhere:@&amp;quot;tag = &amp;#39;iOS&amp;#39; AND author = &amp;#39;zengjing&amp;#39;&amp;quot;] sortedResultsUsingProperty:@&amp;quot;num&amp;quot; ascending:YES];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;4）链式查询(结果过滤)&lt;/p&gt;

&lt;p&gt;假设要查询所有所属分组是iOS的文章，然后从中筛选出作者是zengjing的数据：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;RLMResults *results1 = [Article objectsWhere:@&amp;quot;tag = &amp;#39;iOS&amp;#39;&amp;quot;];
RLMResults *results2 = [results1 objectsWhere:@&amp;quot;author = &amp;#39;zengjing&amp;#39;&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;4、通知&lt;/h4&gt;

&lt;p&gt;每当一次写事务完成Realm实例都会向其他线程上的实例发出通知，可以通过注册一个block来响应通知：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;self.token = [realm addNotificationBlock:^(NSString *note, RLMRealm * realm) {
    [_listTableView reloadData];
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;只要有任何的引用指向这个返回的notification token，它就会保持激活状态。在这个注册更新的类里，你需要有一个强引用来钳制这个token， 因为一旦notification token被释放，通知也会自动解除注册。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@property (nonatomic, strong) RLMNotificationToken *token;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;另外可以使用下面的方式解除通知：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[realm removeNotification:self.token];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h4&gt;5、数据库版本迁移&lt;/h4&gt;

&lt;p&gt;当你和数据库打交道的时候，时不时的你需要改变数据模型（model），但因为Realm中得数据模型被定义为标准的Objective-C interfaces，要改变模型，就像改变其他Objective-C interface一样轻而易举。举个例子，假设有个数据模型&lt;code&gt;Person&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;在v1.0中数据模型如下：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// v1.0
@interface Person : RLMObject
@property NSString *firstName;
@property NSString *lastName;
@property int age;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;升级到v2.0之后将firstName和lastName字段合并为一个字段fullName&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// v2.0
@interface Person : RLMObject
@property NSString *fullName; // new property
@property int age;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;迁移的逻辑可以为：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[RLMRealm setSchemaVersion:2.0 forRealmAtPath:[RLMRealm defaultRealmPath] 
                         withMigrationBlock:^(RLMMigration *migration, 
                                              NSUInteger oldSchemaVersion) {
  [migration enumerateObjects:Person.className 
                        block:^(RLMObject *oldObject, RLMObject *newObject) {
    if (oldSchemaVersion &amp;lt; 2.0) {
      newObject[@&amp;quot;fullName&amp;quot;] = [NSString stringWithFormat:@&amp;quot;%@ %@&amp;quot;, oldObject[@&amp;quot;firstName&amp;quot;], oldObject[@&amp;quot;lastName&amp;quot;]];
    }
  }];
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当版本升级到3.0时，添加新的属性email&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;// v3.0
@interface Person : RLMObject
@property NSString *fullName;
@property NSString *email;   // new property
@property int age;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;迁移的逻辑可以为：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[RLMRealm setSchemaVersion:2.0 forRealmAtPath:[RLMRealm defaultRealmPath] 
                         withMigrationBlock:^(RLMMigration *migration, 
                                              NSUInteger oldSchemaVersion) {
  [migration enumerateObjects:Person.className 
                        block:^(RLMObject *oldObject, RLMObject *newObject) {
    //处理v2.0的更新
    if (oldSchemaVersion &amp;lt; 2.0) {
      newObject[@&amp;quot;fullName&amp;quot;] = [NSString stringWithFormat:@&amp;quot;%@ %@&amp;quot;, oldObject[@&amp;quot;firstName&amp;quot;], oldObject[@&amp;quot;lastName&amp;quot;]];
    }
    //处理v3.0的更新
    if(oldSchemaVersion &amp;lt; 3.0) {
        newObject[@&amp;quot;email&amp;quot;] = @&amp;quot;&amp;quot;;
    }
  }];
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;说明（摘自官方的FAQ）&lt;/h3&gt;

&lt;p&gt;1、realm的支持库有多大？&lt;/p&gt;

&lt;p&gt;一旦你的app编译完成，realm的支持库应该只有1MB左右。我们发布的那个可能有点大（iOS ~37MB, OSX ~2.4MB）， 那是因为它们还包含了对其他构架的支持（ARM，ARM64，模拟器的是X86）和一些编译符号。 这些都会在你编译app的时候被Xcode自动清理掉。&lt;/p&gt;

&lt;p&gt;2、我应该在正式产品中使用realm吗？&lt;/p&gt;

&lt;p&gt;自2012年起，realm就已经开始被用于正式的商业产品中了。正如你预期，我们的objective-c &amp;amp; Swift API 会随着社区的反馈不断的完善和进化。 所以，你也应该期待realm带给你更多的新特性和版本修复。&lt;/p&gt;

&lt;p&gt;3、我要付realm的使用费用吗？&lt;/p&gt;

&lt;p&gt;不要， Realm的彻底免费的， 哪怕你用于商业软件。&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;https://realm.io/docs/objc/latest&quot;&gt;《Realm Document》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.jianshu.com/p/052c763d5693&quot;&gt;《Realm数据库基础教程》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Jul 2015 19:10:40 +0800</pubDate>
        <link>http://blog.devzeng.com/simple-usage-of-realm-in-ios.html</link>
        <guid isPermaLink="true">http://blog.devzeng.com/simple-usage-of-realm-in-ios.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>GitLab的简单使用</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://about.gitlab.com&quot;&gt;GitLab&lt;/a&gt;是一个利用&lt;code&gt;Ruby on Rails&lt;/code&gt;开发的开源应用程序，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gitlab_usage/logo.png&quot; alt=&quot;logo.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;它拥有与Github类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。开源中国代码托管平台&lt;code&gt;git.oschina.net&lt;/code&gt;就是基于GitLab项目搭建。&lt;/p&gt;

&lt;h3&gt;添加新项目&lt;/h3&gt;

&lt;p&gt;1、选择创建新项目&lt;/p&gt;

&lt;p&gt;登录成功后，点击导航条上的 “+” 就可以进入创建项目的页面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gitlab_usage/new_project_1.png&quot; alt=&quot;new_project_1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;2、填写项目的信息&lt;/p&gt;

&lt;p&gt;在创建工程的页面，按照要求填写项目的名称和可见性等信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gitlab_usage/new_project_2.png&quot; alt=&quot;new_project_2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;（1）Project path：项目的路径，一般可以认为是项目的名称&lt;/p&gt;

&lt;p&gt;（2）Import prject from：从哪导入项目，提供Github/Bitbucket等几个选项&lt;/p&gt;

&lt;p&gt;（3）Description（项目的描述）：可选项，对项目的简单描述&lt;/p&gt;

&lt;p&gt;（4）Visibility Level（项目可见级别）：提供Private（私有的，只有你自己或者组内的成员能访问）/Internal（所有登录的用户）/Public(公开的，所有人都可以访问)三种选项。&lt;/p&gt;

&lt;h3&gt;添加和配置SSH公钥&lt;/h3&gt;

&lt;p&gt;SSH（Secure Shell）是一种安全协议，在你的电脑与GitLab服务器进行通信时，我们使用SSH密钥（SSH Keys）认证的方式来保证通信安全。你可以在网络上搜索到关于SSH密钥的更多介绍；下面我们重点讲解如何创建 SSH密钥，并将密钥中的公钥添加到GitLab，以便我们通过SSH协议来访问Git仓库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gitlab_usage/add_sshkey_3.gif&quot; alt=&quot;add_sshkey_3.gif&quot;&gt;&lt;/p&gt;

&lt;p&gt;SSH 密钥的创建需要在终端（命令行）环境下进行，我们首先进入命令行环境。通常在OS X和Linux平台下我们使用终端工具（Terminal），在Windows平台中，可以使用Git Bash工具。&lt;/p&gt;

&lt;p&gt;进入命令行环境后，我们执行以下操作来创建 SSH 密钥。&lt;/p&gt;

&lt;h4&gt;1.进入SSH目录&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;cd  ~/.ssh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;（1）如果还没有 ~/.ssh 目录，可以手工创建一个(&lt;code&gt;mkdir ~/.ssh&lt;/code&gt;)，之后再通过&lt;code&gt;cd ~/.ssh&lt;/code&gt;进入SSH目录&lt;/p&gt;

&lt;p&gt;（2）可以通过&lt;code&gt;ls -l&lt;/code&gt;命令查看SSH目录下的文件，来确认你是否已经生成过SSH密钥；如果SSH目录为空，我们开始第二步，生成 SSH 密钥；如果存在id_rsa.pub这个文件，说明你之前生成过SSH密钥，后面有介绍如何添加多个sshkey&lt;/p&gt;

&lt;h4&gt;2.生成SSH密钥&lt;/h4&gt;

&lt;p&gt;我们通过下面的命令生成密钥，请将命令中的&lt;code&gt;YOUR_EMAIL@YOUREMAIL.COM&lt;/code&gt;替换为你自己的&lt;code&gt;Email&lt;/code&gt;地址。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;YOUR_EMAIL@YOUREMAIL.COM&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在SSH生成过程中会出现以下信息，按屏幕的提示操作即可；&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;$ ssh-keygen -t rsa -C &amp;quot;YOUR_EMAIL@YOUREMAIL.COM&amp;quot;
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/USERNAME/.ssh/id_rsa.
Your public key has been saved in /Users/USERNAME/.ssh/id_rsa.pub.
The key fingerprint is:
15:81:d2:7a:c6:6c:0f:ec:b0:b6:d4:18:b8:d1:41:48 YOUR_EMAIL@YOUREMAIL.COM
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;（1）一般情况下，在命令行中输入密码、口令一类的信息时是没有信息回显的。在我们这一步的操作中，输入passphrase口令时，命令行界面上不会随着键盘敲入密码而有什么反馈。&lt;/p&gt;

&lt;p&gt;（2）当提示&lt;code&gt;Enter passphrase (empty for no passphrase) :&lt;/code&gt;时，可以直接按两次回车键输入一个空的 passphrase；也可以选择输入一个 passphrase 口令，如果此时你输入了一个&lt;code&gt;passphrase&lt;/code&gt;，请牢记，之后每次提交时都需要输入这个口令来确认。&lt;/p&gt;

&lt;h4&gt;3.获取SSH公钥信息&lt;/h4&gt;

&lt;p&gt;SSH密钥生成结束后，你可以在SSH目录下看到私钥&lt;code&gt;id_rsa&lt;/code&gt;和公钥&lt;code&gt;id_rsa.pub&lt;/code&gt;这两个文件，不要把私钥文件&lt;code&gt;id_rsa&lt;/code&gt;的信息透露给任何人。我们可以通过文本编辑器或&lt;code&gt;cat&lt;/code&gt;命令来查看&lt;code&gt;id_rsa.pub&lt;/code&gt;公钥信息。&lt;/p&gt;

&lt;p&gt;（1）通过编辑器。使用你熟悉的文本编辑器，比如 记事本、Sublime Text等软件打开&lt;code&gt;id_rsa.pub&lt;/code&gt;，复制里面的所有内容以备下一步使用。&lt;/p&gt;

&lt;p&gt;（2）通过cat命令。在命令行中敲入&lt;code&gt;cat id_rsa.pub&lt;/code&gt;，回车执行后命令行界面中会显示&lt;code&gt;id_rsa.pub&lt;/code&gt;文件里的内容，复制后在下一步使用。&lt;/p&gt;

&lt;p&gt;（3）通过直接使用命令将&lt;code&gt;id_rsa.pub&lt;/code&gt;文件里的内容复制到剪切板中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Windows: &lt;code&gt;clip &amp;lt; ~/.ssh/id_rsa.pub&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Mac: &lt;code&gt;pbcopy &amp;lt; ~/.ssh/id_rsa.pub&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GNU/Linux (requires xclip): &lt;code&gt;xclip -sel clip &amp;lt; ~/.ssh/id_rsa.pub&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;4.添加SSH公钥到gitlab&lt;/h4&gt;

&lt;p&gt;（1）打开&lt;code&gt;https://gitlab.com/profile&lt;/code&gt;Profile配置页面，选择SSH Keys.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gitlab_usage/add_sshkey_1.png&quot; alt=&quot;add_sshkey_1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;（2）添加SSH公钥&lt;/p&gt;

&lt;p&gt;按照要求填写Title和Key，其中Title是Key的描述信息（如My_work_computer等），Key是上面复制的SSH公钥的内容，直接粘贴到输入框中保存即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gitlab_usage/add_sshkey_2.png&quot; alt=&quot;add_sshkey_2.png&quot;&gt;&lt;/p&gt;

&lt;h4&gt;5.测试SSH连接&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;ssh -T git@gitlab.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果连接成功的话，会出现以下信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Welcome to GitLab, USERNAME!&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;如何同时使用多个SSH公钥&lt;/h3&gt;

&lt;p&gt;如果你已经有了一套ssh(笔者的电脑上就有好几套如github/gitcafe/gitlab,三者各不一样)，为了保证各个服务能正常使用需要配置多个SSH Key。可以按照以下的步骤来实现多套SSH Key的共同工作：&lt;/p&gt;

&lt;h4&gt;1.生成SSH密钥&lt;/h4&gt;

&lt;p&gt;假设你已经有了一套名为id_rsa的公秘钥，将要生成的公秘钥名称为gitlab，你也可以使用任何你喜欢的名字。记得把以下命令中的&lt;code&gt;YOUR_EMAIL@YOUREMAIL.COM&lt;/code&gt;改为你的&lt;code&gt;Email&lt;/code&gt;地址&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;YOUR_EMAIL@YOUREMAIL.COM&amp;quot; -f ~/.ssh/gitlab&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;（1）&lt;code&gt;-f&lt;/code&gt;后面的参数是自定义的SSH Key的存放路径，将来生成的公秘钥的名字分别是gitlab.pub和gitlab&lt;/p&gt;

&lt;p&gt;（2）其他的和上面生成密钥的步骤相同，只是多了下面的配置的步骤&lt;/p&gt;

&lt;h4&gt;2.配置自定义的公秘钥名称&lt;/h4&gt;

&lt;p&gt;在SSH用户配置文件~/.ssh/config中指定对应服务所使用的公秘钥名称，如果没有config文件的话就新建一个(&lt;code&gt;vim ~/.ssh/config&lt;/code&gt;)，并输入以下内容(可以添加多个)：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Host gitlab.com www.gitlab.com
  IdentityFile ~/.ssh/gitlab
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;导入项目或提交代码&lt;/h3&gt;

&lt;p&gt;1、初始上传代码&lt;/p&gt;

&lt;p&gt;（1）可以先将项目clone到本地然后将文件拷贝到目录下面再提交上去&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;git clone git@gitlab.com:USERNAME/PROJECTNAME.git
cd WatchDemo
touch README.md
git add README.md
git commit -m &amp;quot;add README&amp;quot;
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;（2）如果项目存在需要导入到gitlab可以直接将项目导入上去&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;cd existing_folder
git init
git remote add origin git@gitlab.com:USERNAME/PROJECTNAME.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;（1）请将上面的USERNAME和PROJECTNAME替换成用户名和项目的名称&lt;/p&gt;

&lt;p&gt;（2）existing_folder指的是项目在本地的路径（根路径）&lt;/p&gt;

&lt;p&gt;2、其他使用请参考&lt;a href=&quot;http://blog.devzeng.com/blog/github-code-repository.html&quot;&gt;《使用GitHub进行项目托管》&lt;/a&gt;，或者是到网络上查看Git的相关资料&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;感谢&lt;a href=&quot;https://gitcafe.com&quot;&gt;GitCafe&lt;/a&gt;，一个非常优秀的代码托管平台，本文很多资料来源于GitCafe官方提供的&lt;a href=&quot;https://help.gitcafe.com/manuals/help&quot;&gt;帮助手册&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;https://gitlab.com/help/&quot;&gt;《GitLab Help》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;https://help.gitcafe.com/manuals/help/ssh-key&quot;&gt;《Gitcafe Help》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://blog.cnbluebox.com/blog/2014/04/15/gitlabde-shi-yong/&quot;&gt;《Gitlab的使用》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://segmentfault.com/a/1190000000345686&quot;&gt;《用GitLab搭建自己的私有GitHub》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Jul 2015 04:05:48 +0800</pubDate>
        <link>http://blog.devzeng.com/simple-usage-of-gitlab.html</link>
        <guid isPermaLink="true">http://blog.devzeng.com/simple-usage-of-gitlab.html</guid>
        
        <category>Note</category>
        
        
      </item>
    
      <item>
        <title>初识Apple Watch应用开发</title>
        <description>&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/hello_watch.jpg&quot; alt=&quot;hello_watch.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;自发布iOS8.2 SDK和Xcode6.2来，大家对于WatchKit的关注就不绝于耳。特别随着Apple Watch的发售一大批的Apple Watch的应用就如雨后春笋一般涌入AppStore。本文对&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide&quot;&gt;《WatchKit Programming Guide》&lt;/a&gt;中提到的相关概念结合目前的各方资料进行整理，重点介绍在Apple Watch开发中的一些基本概念和数据通信方面的内容。&lt;/p&gt;

&lt;h3&gt;配置Xcode添加Watch应用&lt;/h3&gt;

&lt;p&gt;1、使用最新的Xcode(Xcode 6.2及以上)打开现有的iOS项目&lt;/p&gt;

&lt;p&gt;2、选择File -&amp;gt; New -&amp;gt; Target, 选择Apple Watch&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/new_target.png&quot; alt=&quot;new_target.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;3、选择WatchKit App&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/watchkit_app.png&quot; alt=&quot;watchkit_app.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;4、如果您想要使用glance或者自定义通知界面，请选择相应的选项(推荐激活应用通知选项)。选中之后就会创建一个新的文件来调试该通知界面。如果您没有选择这个选项，那么之后只能手动创建这个文件了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/watchapp_config.png&quot; alt=&quot;watchapp_config.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;完成上述操作之后，Xcode会自动创建两个Target：WatchKit应用扩展(WatchKit Extension)和Watch应用(Watch App)，并自动配置相应的设置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/target_structure.jpg&quot; alt=&quot;target_structure.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;(1)Xcode将基于iOS应用的bundle ID来为两个新对象设置它们的bundle ID。比如说，iOS应用的bundle ID为&lt;code&gt;com.example.MyApp&lt;/code&gt;，那么Watch应用的bundle ID将被设置为 &lt;code&gt;com.example.MyApp.watchapp&lt;/code&gt;，WatchKit应用扩展的bundle ID被设置为&lt;code&gt;com.example.MyApp.watchkitextension&lt;/code&gt;。这三个可执行对象的基本ID（即&lt;code&gt;com.example.MyApp&lt;/code&gt;）必须相匹配，如果更改了iOS应用的bundle ID，那么就必须相应的更改另外两个对象的bundle ID。&lt;/p&gt;

&lt;p&gt;(2)上面的结构图描述了iOS App、WatchKit Extension和Watch App三者之间的依赖关系。WatchKit依赖于iOS应用，而其同时又被Watch应用依赖。编译iOS应用将会将这三个对象同时编译并打包。其中Watch App运行在Watch上，只包含Storyboards和资源文件；WatchKit Extension运行在iPhone上，和对应的iPhone App在一起。用户点击Watch App后，与Watch匹配的iPhone会启动WatchKit Extension，然后和Watch建立连接，然后两者可以进行交互。&lt;/p&gt;

&lt;h3&gt;iPhone App、WatchKit Extension和Watch App之间的关系&lt;/h3&gt;

&lt;p&gt;自iOS8起Apple推出一个新的概念-App Extension,可以让开发者开发第三方的键盘、通知中心（Today Widget）等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/iphone_watch_communication.png&quot; alt=&quot;iphone_watch_communication.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;WatchKit Extension是iPhone App和Watch App通信的桥梁，下图展示了三者间的关系：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/watchkit_communication.jpg&quot; alt=&quot;watchkit_communication.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;1、WatchKit Extension(Extension)和Watch App(Host App)间的通信&lt;/p&gt;

&lt;p&gt;在Extension中可以获取到Watch App界面元素的数据接口&lt;code&gt;WKInterfaceObject&lt;/code&gt;（非控件View本身，更接近于Model），通过修改WKInterfaceObject的数据，来修改对应Watch App的界面。另外通过Xcode将Watch App控件的响应事件绑定到Extension中，可以实现Watch操作响应逻辑的处理。&lt;/p&gt;

&lt;p&gt;2、WatchKit Extension(Extension)和iPhone App(Containing App)的通信&lt;/p&gt;

&lt;p&gt;(1)共享存储空间&lt;/p&gt;

&lt;p&gt;Extension和iPhone App之间的一种通信方式是读写同一块共享存储空间，达到数据交换的目的（见下图）。需要注意的是Extension和iPhone App属于不同的进程，要共享存储空间，需要在工程对应的target中同时打开App Groups的权限，并选择共享的组名（打开权限需要在Xcode中配置开发者账号和密码，同时本地需要有对应的开发证书，本文后面有介绍）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/share_container.png&quot; alt=&quot;share_container.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;(2)直接进行通信&lt;/p&gt;

&lt;p&gt;Extension和iPhone App另外一种通信方式是Extension主动向iPhone App发起请求，进行某种操作，或者请求数据（场景：Watch 收到新邮件通知后，点击已读按钮，在iPhone App上置已读）。&lt;/p&gt;

&lt;p&gt;WatchKit Extension中向iPhone App发送请求：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;+ (BOOL)openParentApplication:(NSDictionary * nonnull)userInfo reply:(void (^ nullable)(NSDictionary * nonnull replyInfo, NSError * nullable error))reply;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在iPhone App的AppDelegate中实现如下方法响应Watch App的请求：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (void)application:(UIApplication * nonnull)application handleWatchKitExtensionRequest:(NSDictionary * nullable)userInfo reply:(void (^ nonnull)(NSDictionary * nullable replyInfo))reply;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在Github上找到一个叫做&lt;a href=&quot;https://github.com/mutualmobile/MMWormhole&quot;&gt;MMWormhole&lt;/a&gt;的开源库，它是专门用于Container App与Extension间传递消息，整个项目非常简洁实用。&lt;/p&gt;

&lt;p&gt;(1)初始化MMWormhole，需要指定App Group配置的Identifer&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;self.wormhole = [[MMWormhole alloc] initWithApplicationGroupIdentifier:kGroupIdentifer optionalDirectory:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;(2)监听指定标识的消息，并作出相应的处理&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[self.wormhole listenForMessageWithIdentifier:@&amp;quot;user&amp;quot; listener:^(id message) {
        self.label.text = [NSString stringWithFormat:@&amp;quot;%@&amp;quot;, message];
    }];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;(3)发送消息，需要指定标识符&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;[self.wormhole passMessageObject:@{@&amp;quot;name&amp;quot;:@&amp;quot;zengjing&amp;quot;} identifier:@&amp;quot;user&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;Watch App的启动过程和生命周期&lt;/h3&gt;

&lt;p&gt;当用户在Apple Watch上运行应用时，用户的iPhone会自行启动相应的WatchKit应用扩展。通过一系列的信号交换，Watch App和WatchKit Extension互相连接，因此消息能够在二者之间流通，直到用户停止与应用进行交互为止。此时，iOS将暂停应用扩展的运行。&lt;/p&gt;

&lt;p&gt;在启动的过程中，WatchKit自动为当前界面创建相应的界面控制器。如果用户正在查看glance，WatchKit创建出来的界面控制器将与glance相连接。如果用户直接启动应用，WatchKit将从应用的主故事板文件中加载初始界面控制器。无论哪种情况，WatchKit应用扩展都提供一个名为WKInterfaceController的子类来管理相应的界面。&lt;/p&gt;

&lt;p&gt;1、启动Watch App的过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/launch_cycle_2x.png&quot; alt=&quot;launch_cycle_2x.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;当用户在Apple Watch上与应用进行交互时，WatchKit应用扩展将保持运行。如果用户明确退出应用或者停止与Apple Watch进行交互，那么iOS将停用当前界面控制器，并暂停应用扩展的运行。与Apple Watch的互动是非常短暂的，因此这几个步骤都有可能在数秒之间发生。所以，界面控制器应当尽可能简单，并且不要运行长时任务。重点应当放在读取和显示用户想要的信息上来。&lt;/p&gt;

&lt;p&gt;2、界面控制器的生命周期&lt;/p&gt;

&lt;p&gt;当应用启动时，WatchKit框架自行创建了相应的&lt;code&gt;WKInterfaceController&lt;/code&gt;对象并调用&lt;code&gt;initWithContext:&lt;/code&gt;方法。使用该方法来初始化界面控制器，然后加载所需的数据，最后设置所有界面对象的值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/watch_app_lifecycle_simple_2x.png&quot; alt=&quot;watch_app_lifecycle_simple_2x.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;在应用生命周期的不同阶段，iOS将会调用WKInterfaceController对象的相关方法来让您做出相应的操作。WKInterfaceController的几个主要的方法说明如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;initWithContext：这个方法用来准备显示界面。借助它来加载数据，以及更新标签、图像和其他在Storyboard场景上的界面对象。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;willActivate：这个方法可以让您知道该界面是否对用户可视。借助它来更新界面对象，以及完成相应的任务，完成任务只能在界面可视时使用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;didDeactivate：使用didDeactivate方法来执行所有的清理任务。例如，使用此方法来废止计时器、停止动画或者停止视频流内容的传输。您不能在这个方法中设置界面控制器对象的值，在本方法被调用之后到willActivate方法再次被调用之前，任何更改界面对象的企图都是被忽略的。 &lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;说明：glances不支持动作方法。单击应用glance始终会启动应用。&lt;/p&gt;

&lt;h3&gt;App Group配置&lt;/h3&gt;

&lt;p&gt;1、打开开发者中心后台,选择Certificates, Identifiers &amp;amp; Profiles&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://developer.apple.com/membercenter/index.action&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/membercenter_home.png&quot; alt=&quot;membercenter_home.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;2、选择Identifiers下面的App Groups分组，然后点击右上角的加号创建一个新的分组&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/app_groups_1.png&quot; alt=&quot;app_groups_1.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;3、填写App Groups的描述信息和Identifier字符串，其中ID必须以group开头，推荐的格式是&lt;code&gt;group.域名反转.应用的名称&lt;/code&gt;, 如&lt;code&gt;group.com.devzeng.mydemo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/app_groups_2.png&quot; alt=&quot;app_groups_2.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;4、在Xcode中进行配置,Targets -&amp;gt; Capabilities -&amp;gt; App Groups中开启选项，并设置为上面添加的ID(iPhone App和WatchKit Extension中都需要进行设置)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/apple_watch_dev_glance/app_groups_4.png&quot; alt=&quot;app_groups_4.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://nilsun.github.io/apple-watch/&quot;&gt;《Apple Watch开发初探》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://nilsun.github.io/iPhone-watch-communication/&quot;&gt;《Apple Watch和iPhone通信实践》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/WatchKitProgrammingGuide&quot;&gt;《WatchKit Programming Guide》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://www.cocoachina.com/ios/20141217/10660.html&quot;&gt;《Apple Watch编程指南（中文版）》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5、&lt;a href=&quot;http://yulingtianxia.com/blog/2015/04/06/Communication-between-your-App-and-Extensions/&quot;&gt;《App与Extensions间通信共享数据》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Jul 2015 22:35:09 +0800</pubDate>
        <link>http://blog.devzeng.com/apple-watch-development-at-glance.html</link>
        <guid isPermaLink="true">http://blog.devzeng.com/apple-watch-development-at-glance.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>合理使用Python助力iOS开发</title>
        <description>&lt;p&gt;说明：本文并不是介绍关于Python如何使用或者是Python的语法知识的，重点是分享在开发中使用Python来减少重复性的劳动的思路。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/python_ios/python_logo.png&quot; alt=&quot;python_logo.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.python.org&quot;&gt;Python&lt;/a&gt;是一种面向对象、解释型计算机程序设计语言，由&lt;code&gt;Guido van Rossum&lt;/code&gt;于1989年底发明，第一个公开发行版发行于1991年，Python 源代码同样遵循 GPL(GNU General Public License)协议 。Python语法简洁而清晰，具有丰富和强大的类库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。&lt;/p&gt;

&lt;p&gt;Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。&lt;/p&gt;

&lt;p&gt;除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。&lt;/p&gt;

&lt;p&gt;许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。&lt;/p&gt;

&lt;h3&gt;安装Python第三方模块&lt;/h3&gt;

&lt;p&gt;在Python中，安装第三方模块，是通过包管理工具pip完成的，在终端中尝试运行pip如果提示未找到该命令，需要先安装pip。&lt;/p&gt;

&lt;p&gt;(1)下载pip的安装脚本&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;wget https://bootstrap.pypa.io/get-pip.py
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;(2)执行安装脚本，安装pip&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;sudo python get-pip.py 
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;一般来说，第三方库都会在Python官方的&lt;code&gt;pypi.python.org&lt;/code&gt;网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索。比如使用比较频繁的一个用于解析HTML的库BeautifulSoup，因此安装BeautifulSoup的命令为：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;pip install BeautifulSoup
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;只要耐心等待下载并安装后，就可以使用了。另外其他常用的第三方库还有MySQL的驱动：mysql-connector-python，用于科学计算的NumPy库：numpy，用于生成文本的模板工具Jinja2，等等。&lt;/p&gt;

&lt;h3&gt;案例&lt;/h3&gt;

&lt;p&gt;1、抓取&lt;code&gt;http://blog.devzeng.com&lt;/code&gt;网站下面的所有文章的名称和链接。适用于模拟爬虫的功能，将某些网站上面的数据抓取回来。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/python
#-*- coding: utf-8 -*-
#encoding=utf-8

import urllib,re,json,time,sys
from BeautifulSoup import BeautifulSoup

#获取指定的URL的内容
def getHtmlContent(url):
    page = urllib.urlopen(url)
    html = page.read()
    return html

#获取全部的文章的链接
def getAllHtmlLink(html, url):
    arr = []
    pattern = u&amp;#39;&amp;lt;a.*?href=&amp;quot;(.+)&amp;quot;.*?&amp;gt;(.*?)&amp;lt;/a&amp;gt;&amp;#39;
    soup = BeautifulSoup(html)
    articleResult = soup.findAll(&amp;#39;article&amp;#39;)
    for article in articleResult:
        h1Result = article.findAll(&amp;#39;h1&amp;#39;)
        for h1 in h1Result:
            aResult = h1.findAll(&amp;#39;a&amp;#39;)
            for a in aResult:
                ret = re.search(pattern, str(a))
                if ret:
                    map = {}
                    group = ret.groups()
                    map[&amp;#39;title&amp;#39;] = group[1]
                    map[&amp;#39;link&amp;#39;] = url + group[0]
                    arr.append(map)
    return arr

#转换成JSON字符串
def toJSONString(arr):
    return json.dumps(arr)

#保存内容到文件
def saveToFile(path, json):
    fp = open(path, &amp;#39;w&amp;#39;)
    fp.write(json)
    fp.close()

if __name__==&amp;quot;__main__&amp;quot;:
    start = time.time()
    url = &amp;quot;http://blog.devzeng.com&amp;quot;
    html = getHtmlContent(url + &amp;quot;/blog/archives&amp;quot;)
    result = getAllHtmlLink(html, url)
    json = toJSONString(result)
    print type(json.encode(&amp;#39;utf-8&amp;#39;).decode(&amp;#39;utf-8&amp;#39;))
    saveToFile(&amp;quot;blog.txt&amp;quot;, json)
    c = time.time() - start
    print(&amp;#39;执行完成，程序运行耗时:%0.2fs&amp;#39;%(c))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;(1)依赖BeautifulSoup模块，使用前需要先安装&lt;code&gt;BeautifulSoup&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(2)思路是先读取网址的HTML内容，然后解析HTML中的指定的链接标签分析里面的数据然后整合到一起&lt;/p&gt;

&lt;p&gt;(3)def开头的是函数，函数名后面有冒号，没有花括号的区分用代码缩进来判断是不是一个代码块的内容。&lt;/p&gt;

&lt;p&gt;2、前段时间的项目是使用WebService作为网络API接口，为了保证请求参数的完整和顺序的一致需要将WSDL文件下载下来进行解析。但是每次手动的处理都是一件很费体力的事情，而且经常容易遗漏一些东西。使用Python之后就极大的方便了我们的开发。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#!/usr/bin/python
#-*- coding: utf-8 -*-
#encoding=utf-8

import urllib,re
from BeautifulSoup import BeautifulSoup

#获取指定的URL的内容
def getHtmlContent(url):
    page = urllib.urlopen(url)
    html = page.read()
    return html

#获取全部的超链接的内容
def getAllHrefLink(url, html):
        soup = BeautifulSoup(html)
        aResult = soup.findAll(&amp;#39;a&amp;#39;)
        pattern = u&amp;#39;&amp;lt;a.*?href=&amp;quot;(.+)&amp;quot;.*?&amp;gt;(.*?)&amp;lt;/a&amp;gt;&amp;#39;
        for a in aResult:
            ret = re.search(pattern, str(a))
            if ret:
                group = ret.groups()
                name = group[1].replace(&amp;#39;.asmx&amp;#39;, &amp;#39;.xml&amp;#39;)
                link = url+group[0]
                if name != u&amp;#39;[To Parent Directory]&amp;#39;:
                    saveData(name, link)

#保存文本内容到指定的路径                
def saveData(path, content):
    f = open(path,&amp;#39;w+&amp;#39;)
    f.write(content)

#调用函数
url = &amp;quot;http://192.168.1.101:8080&amp;quot;
content = getHtmlContent(url + &amp;quot;/Services/&amp;quot;)
getAllHrefLink(url, content)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;https://www.python.org&quot;&gt;《Python官网》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&quot;&gt;《Python 3.0教程》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000&quot;&gt;《Python 2.7教程》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://www.cnblogs.com/SunWentao/archive/2008/06/19/1225690.html&quot;&gt;《python字符串操作》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 07 Jun 2015 03:37:56 +0800</pubDate>
        <link>http://blog.devzeng.com/using-python-in-ios.html</link>
        <guid isPermaLink="true">http://blog.devzeng.com/using-python-in-ios.html</guid>
        
        <category>Python</category>
        
        
      </item>
    
      <item>
        <title>iOS开发中集成Reveal</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://revealapp.com/&quot;&gt;Reveal&lt;/a&gt; 是一个界面调试工具。使用Reveal，我们可以在iOS开发时动态地查看和修改应用程序的界面。它类似Chrome的“审查元素”功能，我们不但可以在运行时看到iOS程序的界面层级关系，还可以实时地修改程序界面，不用重新运行程序就可以看到修改之后的效果。&lt;/p&gt;

&lt;p&gt;在使用时，我们将Reveal连接上模拟器或真机上正在运行的iOS程序，然后就可以查看和调试iOS程序的界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/reveal-hero.png&quot; alt=&quot;reveal-hero.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;下载安装&lt;/h3&gt;

&lt;p&gt;Releal官方提供试用版本，免费试用期是30天，功能和正式版没有差别.&lt;a href=&quot;http://revealapp.com/download/&quot;&gt;点此下载&lt;/a&gt;。&lt;/p&gt;

&lt;h3&gt;配置Reveal&lt;/h3&gt;

&lt;h4&gt;1、配置方式一&lt;/h4&gt;

&lt;p&gt;(1)启动Reveal，选择&lt;code&gt;Reveal -&amp;gt; Help -&amp;gt; Show Reveal Library in Finder&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/show-reveal-library-in-finder.jpg&quot; alt=&quot;show-reveal-library-in-finder.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;(2)在Xcode中打开iOS项目,将&lt;code&gt;Reveal.framework&lt;/code&gt;拖到项目中，如果升级了Reveal，对应的&lt;code&gt;Reveal.framework&lt;/code&gt;文件也要更新到对应的版本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/add-resource-to-project.jpg&quot; alt=&quot;add-resource-to-project.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;(3)选择Target -&amp;gt; Build Phases -&amp;gt; Link Binary With Libraries将Reveal.framework移除。经测试本步骤不是必须的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/remove-framework-from-project.jpg&quot; alt=&quot;remove-framework-from-project.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;(4)在Xcode的&lt;code&gt;Target -&amp;gt; Build Setting -&amp;gt; Other Linker Flags&lt;/code&gt;添加如下几个配置项&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-ObjC -lz -framework Reveal&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/add-linker-flags.jpg&quot; alt=&quot;add-linker-flags.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;(5)运行项目，然后打开Reveal的界面，在左上角选择连接的设备&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/reveal-app-chooser.jpg&quot; alt=&quot;reveal-app-chooser.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;然后就可以看到实际的运行效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/reveal_demo.png&quot; alt=&quot;reveal_demo.png&quot;&gt;&lt;/p&gt;

&lt;h4&gt;2、配置方式二&lt;/h4&gt;

&lt;p&gt;Reveal官方介绍了好几种办法使Reveal连接模拟器，都需要修改工程文件。但如果修改了工程文件，就需要参与项目开发的所有人都装有Reveal，下面介绍一种比较方便的方式来集成Reveal，步骤如下：&lt;/p&gt;

&lt;p&gt;首先打开Terminal，输入&lt;code&gt;vim ~/.lldbinit&lt;/code&gt;创建一个名为.lldbinit的文件，然后将如下内容输入到该文件中：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;command alias reveal_load_sim expr (void*)dlopen(&amp;quot;/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib&amp;quot;, 0x2);
command alias reveal_load_dev expr (void*)dlopen([(NSString*)[(NSBundle*)[NSBundle mainBundle]               pathForResource:@&amp;quot;libReveal&amp;quot; ofType:@&amp;quot;dylib&amp;quot;] cStringUsingEncoding:0    x4], 0x2);
command alias reveal_start expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter]           postNotificationName:@&amp;quot;IBARevealRequestStart&amp;quot; object:nil];
command alias reveal_stop expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter]            postNotificationName:@&amp;quot;IBARevealRequestStop&amp;quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;该步骤其实是为lldb设置了4个别名，为了后续方便操作，这4个别名意义如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reveal_load_sim&lt;/code&gt; 为模拟器加载reveal调试用的动态链接库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reveal_load_dev&lt;/code&gt; 为真机加载reveal调试用的动态链接库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reveal_start&lt;/code&gt; 启动reveal调试功能&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reveal_stop&lt;/code&gt;  结束reveal调试功能&lt;/p&gt;

&lt;p&gt;(1)Reveal连接模拟器&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/reveal_load_sim.png&quot; alt=&quot;reveal_load_sim.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;在AppDelegate类的&lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;方法中，作如下3步操作（如下图所示）：&lt;/p&gt;

&lt;p&gt;1)点击该方法左边的行号区域，增加一个断点，之后右击该断点，选择“Edit Breakpoint”。&lt;/p&gt;

&lt;p&gt;2)点击”Action”项边右的”Add Action”,然后输入“reveal_load_sim”&lt;/p&gt;

&lt;p&gt;3)勾选上Options上的”Automatically continue after evaluating”选项。&lt;/p&gt;

&lt;p&gt;(2)Reveal连接真机&lt;/p&gt;

&lt;p&gt;要用Reveal连接真机调试，我们需要先把Reveal的动态链接库上传到真机上。由于iOS设备有沙盒存在，所以我们只能将Reveal的动态链接库添加到工程中。&lt;/p&gt;

&lt;p&gt;1)点击Reveal菜单栏的”Help”-&amp;gt;”Show Reveal Library in Finder”选项，可以在Finder中显示出Reveal的动态链接库：&lt;code&gt;libReveal.dylib&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/show-reveal-library-in-finder.jpg&quot; alt=&quot;show-reveal-library-in-finder.jpg&quot;&gt;&lt;/p&gt;

&lt;p&gt;2)调整&lt;code&gt;libReveal.dylib&lt;/code&gt;的引用方式，这里我们只需要将&lt;code&gt;libReveal.dylib&lt;/code&gt;文件拷贝到Sandbox中，但是我们在引入&lt;code&gt;libReveal.dylib&lt;/code&gt;的时候Xcode默认是以&lt;code&gt;Link Binary With Libraries&lt;/code&gt;的方式的，实际上应该是&lt;code&gt;Copy Bundle Resources&lt;/code&gt;,所以应该先将&lt;code&gt;libReveal.dylib&lt;/code&gt;从&lt;code&gt;Link Binary With Libraries&lt;/code&gt;中移除掉，然后在&lt;code&gt;Copy Bundle Resources&lt;/code&gt;中添加。&lt;/p&gt;

&lt;p&gt;3)安装之前处理模拟器的方式，将配置文件改成&lt;code&gt;reveal_load_dev&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/reveal_load_dev.png&quot; alt=&quot;reveal_load_dev.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;启动后在控制台会出现如下内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/reveal_integrating/reveal_load_console.png&quot; alt=&quot;reveal_load_console.png&quot;&gt;&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://wufawei.com/2013/12/use-reveal-to-inspect-ios-apps/&quot;&gt;《使用Reveal来查看、修改、调试iOS应用》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://blog.ittybittyapps.com/blog/2013/11/07/integrating-reveal-without-modifying-your-xcode-project/&quot;&gt;《Integrating Reveal without modifying your Xcode project》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://c.blog.sina.com.cn/profile.php?blogid=cb8a22ea89000gtw&quot;&gt;《Reveal查看任意app的高级技巧》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 31 May 2015 00:50:23 +0800</pubDate>
        <link>http://blog.devzeng.com/ios-reveal-integrating.html</link>
        <guid isPermaLink="true">http://blog.devzeng.com/ios-reveal-integrating.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>使用Wax给你的应用程序打补丁</title>
        <description>&lt;p&gt;在iOS开发中经常遇到需要对已经上线的APP进行功能微调，或者是一些紧急的Bug修复。对于需要提交到AppStore的程序来说，每次审核的周期都会较长，在审核过程中很有可能因为各种原因被拒。由于Apple的限制，开发者无法在iOS上动态的加载Objective-C源码，使用脚本语言就可以在一定程度上解决这个问题。比如使用HTML+Javascript的方式，支付宝钱包的彩票等功能就是使用这一方式实现的。另外也可以使用Lua脚本来实现，最初我了解到的Lua是使用在游戏上面的，包括Angry Bird在内的很多知名游戏使用了Lua作为其场景设计的语言。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ios_wax_patch/lua_logo.png&quot; alt=&quot;lua_logo.png&quot;&gt;&lt;/p&gt;

&lt;p&gt;Lua是一个小巧的脚本语言。是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo所组成并于1993年开发。 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。&lt;/p&gt;

&lt;p&gt;除了开发游戏，那能不能使用Lua开发iOS的应用程序呢？现在，来着国外的大牛&lt;code&gt;@probablycorey&lt;/code&gt;开源了一个叫做&lt;a href=&quot;http://github.com/probablycorey/wax&quot;&gt;&lt;code&gt;wax&lt;/code&gt;&lt;/a&gt;的项目，实现了Lua对于Objective-C的封装，可以使用Lua语言直接写Objective-C的代码了。虽然作者就宣布不再维护了，但是仍然没有降低该框架的关注度，截止到今天都有1620个star和320次Fork。&lt;/p&gt;

&lt;p&gt;为什么要用Lua开发iOS的应用程序？作者介绍了如下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自动垃圾回收机制。开发者无需关注alloc,retain和release这些；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码少。没有那么多的头文件和数据类型（数组、字典等），以较少的代码实现更强大的功能&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方便使用Cocoa，UITouch，Foundation等framework&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更加容易使用的HTTP请求工具，同REST WebService交互更方便&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lua有闭环（也可以称作blocks）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lua内置正则表达式的匹配的工具&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Xcode快速集成Wax&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/mmin18/WaxPatch&quot;&gt;&lt;code&gt;WaxPatch&lt;/code&gt;&lt;/a&gt;是来自大众点评的屠毅敏开源的项目，通过修改wax的实现达到动态打Patch的功能。主要是修改了wax中的&lt;code&gt;wax_instance.m&lt;/code&gt;文件。具体做法是：在wax中加入了&lt;code&gt;class_replaceMethod&lt;/code&gt;来替换原始实现。项目实现了在程序启动时会从指定地址下载一个包含所有Lua补丁的zip包，通过Wax加载后改变了既有Objective-C实现方法的指向函数，从而改变了程序的行为。&lt;/p&gt;

&lt;p&gt;下面介绍如何在项目中快速集成WaxPatch：&lt;/p&gt;

&lt;p&gt;1、下载&lt;a href=&quot;http://github.com/mmin18/WaxPatch&quot;&gt;WaxPatch&lt;/a&gt;和&lt;a href=&quot;http://github.com/probablycorey/wax&quot;&gt;Wax&lt;/a&gt;的项目到本地。&lt;/p&gt;

&lt;p&gt;2、将源码进行整合处理&lt;/p&gt;

&lt;p&gt;（1）将wax项目中的stdlib目录拷贝到WaxPatch的wax目录下面&lt;/p&gt;

&lt;p&gt;（2）删除/extensions/json/目录下面的yajl-1.0.9.tar.gz和Rakefile文件&lt;/p&gt;

&lt;p&gt;（3）不要拷贝extensions下面的SQLite和XML文件夹&lt;/p&gt;

&lt;p&gt;3、导入到Xcode项目中，除了wax/extensions/json下面yajl的不需要设置ARC外，其他的wax相关的都需要在Build Phrase中设置&lt;code&gt;-fno-objc-arc&lt;/code&gt;（前提条件是项目是ARC工程），拷贝ProtocolLoader.h文件到项目中&lt;/p&gt;

&lt;p&gt;4、启动应用前需要在Document下创建lua目，并设置Lua的环境变量，示例代码如下:&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;- (id)init {
    if(self = [super init]) {
        NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];
        NSString *dir = [doc stringByAppendingPathComponent:@&amp;quot;lua&amp;quot;];
        if(![[NSFileManager defaultManager] fileExistsAtPath:dir isDirectory:NULL] {
            [[NSFileManager defaultManager] createDirectoryAtPath:dir withIntermediateDirectories:YES attributes:nil error:NULL];
        }
        NSString *pp = [[NSString alloc ] initWithFormat:@&amp;quot;%@/?.lua;%@/?/init.lua;&amp;quot;, dir, dir];
        setenv(LUA_PATH, [pp UTF8String], 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;并引入头文件&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;#import &amp;quot;lauxlib.h&amp;quot;
#import &amp;quot;wax.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;5、下载到本地的zip包里面的(解压zip包推荐使用ZipArchive)lua文件需要放到上面的lua目录下面，并执行如下代码启动patch包：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;wax_start(&amp;quot;patch&amp;quot;, luaopen_wax_http, luaopen_wax_json, nil);
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;其中：&lt;code&gt;luaopen_wax_http&lt;/code&gt; (头文件是：&lt;code&gt;wax_http.h&lt;/code&gt;)和 &lt;code&gt;luaopen_wax_json&lt;/code&gt;(头文件是：&lt;code&gt;wax_json.h&lt;/code&gt;) 表示需要使用wax扩展包，参见 &lt;code&gt;wax/extensions/&lt;/code&gt;目录下面的扩展包。&lt;/p&gt;

&lt;p&gt;6、wax不支持arm64如果需要兼容到64位的系统，请参考&lt;a href=&quot;http://www.cnblogs.com/ygm900/p/3732724.html&quot;&gt;《lua（wax框架） 适配 64位操作系统》&lt;/a&gt;文章进行处理。&lt;/p&gt;

&lt;p&gt;7、运行后如果发现报&lt;code&gt;Class &amp;#39;HACK_WAX_DELEGATE_IMPLEMENTOR&amp;#39; defined without specifying a base class&lt;/code&gt;的错误，将如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@interface HACK_WAX_DELEGATE_IMPLEMENTOR &amp;lt;WaxServerDelegate&amp;gt; {}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;改为：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;@interface HACK_WAX_DELEGATE_IMPLEMENTOR : NSObject&amp;lt;WaxServerDelegate&amp;gt; {}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;添加一个NSObject的基类即可&lt;/p&gt;

&lt;h3&gt;示例程序&lt;/h3&gt;

&lt;p&gt;1、推荐阅读wax提供的示例程序。&lt;a href=&quot;http://github.com/probablycorey/wax/tree/master/examples/&quot;&gt;Examples&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、WaxPatch项目。&lt;a href=&quot;http://github.com/mmin18/WaxPatch&quot;&gt;WaxPatch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、完整示例程序稍后会同步到GitHub上&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;https://github.com/mmin18/Create-a-More-Flexible-App&quot;&gt;《如何创建更加灵活的App》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NTIyNTUyMQ==&amp;amp;appmsgid=10000028&amp;amp;itemidx=1&amp;amp;scene=4#wechat_redirect&quot;&gt;《用Lua给你的iOS程序打patch》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5NTIyNTUyMQ==&amp;amp;appmsgid=10000031&amp;amp;itemidx=1&amp;amp;scene=4#wechat_redirect&quot;&gt;《用Lua给你的程序打patch（续）》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://blog.csdn.net/linux_zkf/article/details/17123275&quot;&gt;《基于wax的lua IOS插件开发》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5、&lt;a href=&quot;https://github.com/probablycorey/wax/wiki/Overview&quot;&gt;《quick tour of the Wax framework》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6、&lt;a href=&quot;http://www.cnblogs.com/ygm900/p/3680463.html&quot;&gt;《快速将wax配置到项目中进行lua开发》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 09 May 2015 16:36:36 +0800</pubDate>
        <link>http://blog.devzeng.com/ios-patch-by-wax.html</link>
        <guid isPermaLink="true">http://blog.devzeng.com/ios-patch-by-wax.html</guid>
        
        <category>iOS</category>
        
        
      </item>
    
>>>>>>> ac1c538044f1efeb3be830448c2414f35f8e9269
  </channel>
</rss>
